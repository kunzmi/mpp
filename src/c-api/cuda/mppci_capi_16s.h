#ifndef MPPI_CUDA_CAPI_16S_H
#define MPPI_CUDA_CAPI_16S_H

#include "mppc_capi_defs.h"

// for datatype conversions:
#include "convertScale_16s.h"
// for operations on different channel counts:
#include "copySwapChannelDup_16s.h"

#ifdef __cplusplus
extern "C"
{
#endif

    /// <summary>
    /// Copy image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with mask. Pixels with mask == 0 remain untouched in destination image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                   ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aBorder">Border control paramter</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    MPPErrorCode mppciCopyBorder_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        const Mpp32s aLowerBorderSize[2], MPPBorderType aBorder, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    /// <param name="aBorder">Border control paramter</param>
    MPPErrorCode mppciCopyBorder_16s_C1Cb(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                          const Mpp32s aLowerBorderSize[2], Mpp16s aConstant, MPPBorderType aBorder,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy subpix.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aDelta">Fractional part of source image coordinate</param>
    /// <param name="aInterpolation">Interpolation mode to use</param>
    MPPErrorCode mppciCopySubpix_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        const Mpp32f aDelta[2], MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C1IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, ConstDevPtrMpp8u aMask,
                                    size_t aMaskStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C1IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Transpose image.
    /// </summary>
    MPPErrorCode mppciTranspose_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                       MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                      size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, ConstDevPtrMpp8u aMask,
                                       size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInv_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aScaleFactor,
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                      size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, ConstDevPtrMpp8u aMask,
                                       size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInv_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                      size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, ConstDevPtrMpp8u aMask,
                                       size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MPPRoundingMode aRoundingMode, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C1Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                        MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aScaleFactor,
                                      MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInv_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aScaleFactor,
                                         MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_C1ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                      size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C1MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, ConstDevPtrMpp8u aMask,
                                       size_t aMaskStep, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInv_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_C1IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                             MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_C1I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                           size_t aSrcDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                           size_t aSrcDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_C1I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C1I(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                             size_t aSrcDstStep, Mpp32f aAlpha, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C1IM(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                              size_t aSrcDstStep, Mpp32f aAlpha, ConstDevPtrMpp8u aMask,
                                              size_t aMaskStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = abs(aSrc1)
    /// </summary>
    MPPErrorCode mppciAbs_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = abs(aSrcDst)
    /// </summary>
    MPPErrorCode mppciAbs_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = ~aSrc1 (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = ~aSrcDst (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = exp(aSrc1) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = exp(aSrcDst) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = log(aSrc1) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = log(aSrcDst) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                 size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc1 (aSrc1^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst * aSrcDst (aSrcDst^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = Sqrt(aSrc1) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = Sqrt(aSrcDst) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aAlpha, DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aAlpha, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using alpha opacity values contained in each image. Last color channel is alpha channel, 1
    /// channel images are treated as alpha channel only.
    /// </summary>
    MPPErrorCode mppciAlphaComp_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MPPAlphaOp aAlphaOp,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using constant alpha values.
    /// </summary>
    MPPErrorCode mppciAlphaCompC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp16s aAlpha1,
                                        Mpp16s aAlpha2, MPPAlphaOp aAlphaOp, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst.real = aSrc1, aDst.imag = 0 (converts real valued image to complex with imaginary part = 0)
    /// </summary>
    MPPErrorCode mppciMakeComplex_16s16sc_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16sc aDst,
                                             size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst.real = aSrc1, aDst.imag = aSrcImag (converts two real valued images to one complex image)
    /// </summary>
    MPPErrorCode mppciMakeComplexImag_16s16sc_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrcImag,
                                                 size_t aSrcImagStep, DevPtrMpp16sc aDst, size_t aDstStep,
                                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            MPPFixedFilter aFilter, MPPMaskSize aMaskSize, Mpp16s aConstant,
                                            MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, MPPFixedFilter aFilter,
                                          MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                               MPPFixedFilter aFilter, MPPMaskSize aMaskSize, Mpp16s aConstant,
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MPPFixedFilter aFilter, MPPMaskSize aMaskSize, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                                Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                             Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                           MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                   MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                   Mpp32s aFilterCenter, Mpp16s aConstant, MPPBorderType aBorder,
                                                   MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                 MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                 Mpp32s aFilterCenter, MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                          Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                                Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                                Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                              Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                             MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A specialised box filter for one-channel images that returns in first channel result image the mean value under
    /// the box area and in the second channel the summed squared pixel values. The result can then be used in the
    /// CrossCorrelationCoefficient function.
    /// </summary>
    MPPErrorCode mppciBoxAndSumSquareFilter_16s32f_C1C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                           MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                           MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                           Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A specialised box filter for one-channel images that returns in first channel result image the mean value under
    /// the box area and in the second channel the summed squared pixel values. The result can then be used in the
    /// CrossCorrelationCoefficient function.
    /// </summary>
    MPPErrorCode mppciBoxAndSumSquareFilter_16s32f_C1C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                         MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                         MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                         MPPBorderType aBorder, MppiRect aSrcROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Median filter (only filter sizes 3x3, 5x5 and 7x7 are implemented).
    /// </summary>
    MPPErrorCode mppciMedianFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MppiFilterArea aFilterArea, Mpp32f aNoise, Mpp16s aConstant,
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, Mpp32f aNoise, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                           MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                           MppiSize aDstSize, MppiFilterArea aFilterArea, Mpp32f aDelta,
                                                           Mpp16s aValGT, Mpp16s aValLE, Mpp16s aConstant,
                                                           MPPBorderType aBorder, MppiRect aSrcROI,
                                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                         MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                         MppiSize aDstSize, MppiFilterArea aFilterArea, Mpp32f aDelta,
                                                         Mpp16s aValGT, Mpp16s aValLE, MPPBorderType aBorder,
                                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                       MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea, Mpp16s aConstant,
                                          MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                     MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                     MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                     ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                     Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                   ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                   MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                       MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
                                                       DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag,
                                                       size_t aDstMagStep, DevPtrMpp32f aDstAngle, size_t aDstAngleStep,
                                                       DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep,
                                                       MppiSize aDstSize, MPPNorm aNorm, MPPMaskSize aMaskSize,
                                                       Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_C1R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                        MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
                                                        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag,
                                                        size_t aDstMagStep, DevPtrMpp32f aDstAngle,
                                                        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance,
                                                        size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
                                                        MPPMaskSize aMaskSize, Mpp16s aConstant, MPPBorderType aBorder,
                                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_C1R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                         MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
                                                         DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag,
                                                         size_t aDstMagStep, DevPtrMpp32f aDstAngle,
                                                         size_t aDstAngleStep, DevPtrMpp32f aDstCovariance,
                                                         size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
                                                         MPPMaskSize aMaskSize, Mpp16s aConstant, MPPBorderType aBorder,
                                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_C1R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              Mpp32f aWeight, Mpp32f aThreshold, Mpp16s aConstant,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                            Mpp32f aWeight, Mpp32f aThreshold, MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// For an gradient magnitude image and an gradient orientation image obtained from one of the gradient vector
    /// functions, this function performs canny edge detection.<para/>
    /// aTemp is a single channel unsigned char image with the same dimensions as the source image for temporary
    /// storage.
    /// </summary>
    MPPErrorCode mppciCannyEdge_16s8u_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                          ConstDevPtrMpp32f aSrcAngleBasePtr, size_t aSrcAngleStep,
                                          MppiSize aSrcFullSize, DevPtrMpp8u aTempBasePtr, size_t aTempStep,
                                          MppiSize aTempFullSize, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aDstSize,
                                          Mpp16s aLowThreshold, Mpp16s aHighThreshold, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                           Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                         MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                               Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to
    /// use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                                Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                    MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                    MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                    MPPInterpolationMode aInterpolation, Mpp16s aConstant,
                                                    MPPBorderType aBorder, MppiRect aSrcROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                  MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                  MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                                  MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                       const Mpp64f aShift[2], MPPInterpolationMode aInterpolation, Mpp16s aConstant,
                                       MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                     const Mpp64f aShift[2], MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize<para/>
    /// Simplified API to rescale from source image ROI to destination image ROI.<para/>
    /// NOTE: the result is NOT the same as in NPP using the same function. The shift applied in NPP for the same
    /// function don't make much sense to me, in MPP Resize matches the input extent [-0.5 .. srcWidth-0.5[ to the
    /// output [-0.5 .. dstWidth-0.5[. Whereas NPP applies different strategies for up-and downscaling. In order to get
    /// the same results as in NPP, use an user defined scaling factor of <para/> Vec2d scaleFactor =
    /// Vec2d(dstImg.SizeRoi()) / Vec2d(srcImg.SizeRoi());<para/> and a shift given by ResizeGetNPPShift().
    /// </summary>
    MPPErrorCode mppciResize_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aScale[2], const Mpp64f aShift[2],
                                               MPPInterpolationMode aInterpolation, Mpp16s aConstant,
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             const Mpp64f aScale[2], const Mpp64f aShift[2],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis
    /// </summary>
    MPPErrorCode mppciMirror_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    MPPMirrorAxis aAxis, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis (inplace operation)
    /// </summary>
    MPPErrorCode mppciMirror_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MPPMirrorAxis aAxis, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                        MPPInterpolationMode aInterpolation, Mpp16s aConstant, MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                      MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                      ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                      MPPInterpolationMode aInterpolation, Mpp16s aConstant, MPPBorderType aBorder,
                                      MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                    ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                    ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                    MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, MppiFilterArea aFilterArea,
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea, Mpp16s aConstant,
                                            MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                          MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, Mpp16s aConstant,
                                            MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea, Mpp16s aConstant,
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, Mpp16s aConstant,
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                   DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                   DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                   MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                      MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                      MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                    MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                         MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                                   MppiFilterArea aFilterArea, Mpp16s aConstant, MPPBorderType aBorder,
                                                   MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                 MppiSize aDstSize, ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                                 MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                              size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/>
    /// <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                                     size_t aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/>
    /// If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                                      size_t aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProduct.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProductMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j))
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes dot product of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j))
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                            size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSE.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSEMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H)
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H)
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                              size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/>
    /// <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                                     size_t aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/>
    /// If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                                      size_t aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes infinity norm of difference of pixels between two images.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes infinity norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/> The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                             size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L1 norm of difference of pixels between two images.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L1 norm of difference of pixels between two images where only pixels with mask != 0 are used.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                            size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L2 norm of difference of pixels between two images.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L2 norm of difference of pixels between two images where only pixels with mask != 0 are used.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                            size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes relative infinity norm of difference of pixels between two images.<para/>
    /// The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) / NormInf(Src2)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes relative infinity norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/> The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) /
    /// NormInf(Src2)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                            size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes relative L1 norm of difference of pixels between two images.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L1 norm of difference of pixels between two images where only pixels with mask != 0 are used.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                           size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes relative L2 norm of difference of pixels between two images.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L2 norm of difference of pixels between two images where only pixels with mask != 0 are used.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, ConstDevPtrMpp8u aMask,
                                           size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for PSNR.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciPSNRBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the PSNR of two images.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Result</param>
    /// <param name="aValueRange">The maximum possible pixel value, eg. 255 for 8 bit unsigned int images,
    /// 4095 for 12-bit unsigned images, etc.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciPSNR_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, Mpp64f aValueRange, DevPtrMpp8u aBuffer,
                                     size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes infinity norm.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes infinity norm where only pixels with mask != 0 are
    /// used.<para/> The infinity norm is defined as: NormInf = max(|Src1(i,j)|)
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                         ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                         size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L1 norm.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L1 norm where only pixels with mask != 0 are
    /// used.<para/> The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                        size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L2 norm.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes L2 norm where only pixels with mask != 0 are
    /// used.<para/> The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                        size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst, DevPtrMpp8u aBuffer,
                                    size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                    size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Mean.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                     size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values where only pixels with mask != 0 are used.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                      ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStd.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStdMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values.
    /// </summary>
    /// <param name="aMean">Mean value</param>
    /// <param name="aStd">Standard deviation</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values where only pixels with mask != 0 are used.
    /// </summary>
    /// <param name="aMean">Mean value</param>
    /// <param name="aStd">Standard deviation</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                      ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRangeMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aLowerLimit,
                                             Mpp16s aUpperLimit, DevPtrMpp64u aDst, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range where only pixels with mask != 0 are used.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aLowerLimit,
                                              Mpp16s aUpperLimit, DevPtrMpp64u aDst, ConstDevPtrMpp8u aMask,
                                              size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the image quality index of two images. This implementation is identical to the one in NPP computing a
    /// global index without a sliding window.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndex_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndexWindow.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexWindowBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the QualityIndex of two images. This function is implemented using a sliding window approach as is done
    /// in the original paper / code with a window size of 11x11 pixels.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndexWindow_16s32f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                   size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer,
                                                   size_t aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSSIMBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically this is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSSIM_16s32f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSSSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSSSIMBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Multi-Scale-SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically aSrc1 is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSSSIM_16s32f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Min.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp8u aBuffer,
                                 size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value where only pixels with mask != 0 are used.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, ConstDevPtrMpp8u aMask,
                                  size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Max.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp8u aBuffer,
                                 size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value where only pixels with mask != 0 are used.
    /// </summary>
    /// <param name="aDst">Result</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, ConstDevPtrMpp8u aMask,
                                  size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMax.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value.
    /// </summary>
    /// <param name="aDstMin">Minimum value</param>
    /// <param name="aDstMax">Maximum value</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                    DevPtrMpp16s aDstMax, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value where only pixels with mask != 0 are used.
    /// </summary>
    /// <param name="aDstMin">Minimum value</param>
    /// <param name="aDstMax">Maximum value</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_C1M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                     DevPtrMpp16s aDstMax, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.
    /// </summary>
    /// <param name="aDstMin">Minimum value</param>
    /// <param name="aDstIndexX">X pixel index</param>
    /// <param name="aDstIndexY">Y pixel index</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_C1P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                        DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp8u aBuffer,
                                        size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.
    /// </summary>
    /// <param name="aDstMin">Minimum value</param>
    /// <param name="aDstIndexX">X pixel index</param>
    /// <param name="aDstIndexY">Y pixel index</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_C1P3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                         DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, ConstDevPtrMpp8u aMask,
                                         size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.
    /// </summary>
    /// <param name="aDstMin">Maximum value</param>
    /// <param name="aDstIndexX">X pixel index</param>
    /// <param name="aDstIndexY">Y pixel index</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_C1P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                        DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp8u aBuffer,
                                        size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.
    /// </summary>
    /// <param name="aDstMin">Maximum value</param>
    /// <param name="aDstIndexX">X pixel index</param>
    /// <param name="aDstIndexY">Y pixel index</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_C1P3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                         DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, ConstDevPtrMpp8u aMask,
                                         size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_C1M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices. For multiple occurences of the same value the index
    /// with the lowest flattened index (y * width + x) is returned.
    /// </summary>
    /// <param name="aDstMin">Minimum value</param>
    /// <param name="aDstMax">Maximum value</param>
    /// <param name="aDstIdx">Pixel indices for min/max value</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_C1P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                           DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx, DevPtrMpp8u aBuffer,
                                           size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices where only pixels with mask != 0 are used. For multiple
    /// occurences of the same value the index with the lowest flattened index (y * width + x) is returned.
    /// </summary>
    /// <param name="aDstMin">Minimum value</param>
    /// <param name="aDstMax">Maximum value</param>
    /// <param name="aDstIdx">Pixel indices for min/max value</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_C1P3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                            DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx, ConstDevPtrMpp8u aMask,
                                            size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s32s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s32f_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s64s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s64f_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32s32s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32s64s_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32f64f_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s64f64f_C1(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s32s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst, size_t aDstStep,
                                         Mpp32s aVal, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROISrc,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s32f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aDst, size_t aDstStep,
                                         Mpp32f aVal, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROISrc,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s64s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst, size_t aDstStep,
                                         Mpp64s aVal, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROISrc,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst, size_t aDstStep,
                                         Mpp64f aVal, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROISrc,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32s32s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst,
                                               size_t aDstStep, DevPtrMpp32s aSqr, size_t aSqrStep, Mpp32s aVal,
                                               Mpp32s aValSqr, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                               MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32s64s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst,
                                               size_t aDstStep, DevPtrMpp64s aSqr, size_t aSqrStep, Mpp32s aVal,
                                               Mpp64s aValSqr, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                               MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32f64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aDst,
                                               size_t aDstStep, DevPtrMpp64f aSqr, size_t aSqrStep, Mpp32f aVal,
                                               Mpp64f aValSqr, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                               MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s64f64f_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                               size_t aDstStep, DevPtrMpp64f aSqr, size_t aSqrStep, Mpp64f aVal,
                                               Mpp64f aValSqr, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                               MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = min(aSrc1, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = min(aSrcDst, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = max(aSrc1, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = max(aSrcDst, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramEven.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramEvenBufferSize_16s_C1(size_t *aBufferSize, Mpp32s aNumLevels, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The aLowerLevel (inclusive) and aUpperLevel (exclusive) define the boundaries of the range,
    /// which are evenly segmented into aHist.Size() bins.
    /// </summary>
    /// <param name="aHist">device memory pointer to the computed histogram.
    /// The size of aHist gives the number of bins used.</param>
    /// <param name="aLowerLevel">lower level (inclusive)</param>
    /// <param name="aUpperLevel">upper level (exclusive)</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramEven_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist,
                                           Mpp32s aLowerLevel, Mpp32s aUpperLevel, Mpp32s aNumLevels,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramRangeBufferSize_16s_C1(size_t *aBufferSize, Mpp32s aNumLevels, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the histogram of an image within specified ranges.
    /// </summary>
    /// <param name="aHist">device memory pointer to the computed histogram.
    /// The size of aHist gives the number of bins used.</param>
    /// <param name="aLevels">device memory pointer to the array with the range defintion.
    /// The levels array must be one element larger than the histogram array, as number of
    /// levels = number of bins + 1.</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramRange_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist,
                                            ConstDevPtrMpp32s aLevels, Mpp32s aNumLevels, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the un-normalized cross-correlation.<para/>
    /// Note: in order to compute the common "full" or "same" variant as e.g. in NPP, set the input and output ROIs
    /// accordingly and use BorderType::Constant with aConstant = 0.
    /// </summary>
    MPPErrorCode mppciCrossCorrelation_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                    MppiSize aSrcFullSize, ConstDevPtrMpp16s aTemplate,
                                                    size_t aTemplateStep, MppiSize aTemplateSize, DevPtrMpp32f aDst,
                                                    size_t aDstStep, MppiSize aDstSize, Mpp16s aConstant,
                                                    MPPBorderType aBorder, MppiRect aSrcROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the un-normalized cross-correlation.<para/>
    /// Note: in order to compute the common "full" or "same" variant as e.g. in NPP, set the input and output ROIs
    /// accordingly and use BorderType::Constant with aConstant = 0.
    /// </summary>
    MPPErrorCode mppciCrossCorrelation_16s32f_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  MppiSize aSrcFullSize, ConstDevPtrMpp16s aTemplate,
                                                  size_t aTemplateStep, MppiSize aTemplateSize, DevPtrMpp32f aDst,
                                                  size_t aDstStep, MppiSize aDstSize, MPPBorderType aBorder,
                                                  MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the normalized cross-correlation.<para/>
    /// Note: in order to compute the common "full" or "same" variant as e.g. in NPP, set the input and output ROIs
    /// accordingly and use BorderType::Constant with aConstant = 0.
    /// </summary>
    MPPErrorCode mppciCrossCorrelationNormalized_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                              MppiSize aSrcFullSize, ConstDevPtrMpp16s aTemplate,
                                                              size_t aTemplateStep, MppiSize aTemplateSize,
                                                              DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                                              Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the normalized cross-correlation.<para/>
    /// Note: in order to compute the common "full" or "same" variant as e.g. in NPP, set the input and output ROIs
    /// accordingly and use BorderType::Constant with aConstant = 0.
    /// </summary>
    MPPErrorCode mppciCrossCorrelationNormalized_16s32f_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                            MppiSize aSrcFullSize, ConstDevPtrMpp16s aTemplate,
                                                            size_t aTemplateStep, MppiSize aTemplateSize,
                                                            DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                                            MPPBorderType aBorder, MppiRect aSrcROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the normalized squared distance.<para/>
    /// Note: in order to compute the common "full" or "same" variant as e.g. in NPP, set the input and output ROIs
    /// accordingly and use BorderType::Constant with aConstant = 0.
    /// </summary>
    MPPErrorCode mppciSquareDistanceNormalized_16s32f_C1RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                            MppiSize aSrcFullSize, ConstDevPtrMpp16s aTemplate,
                                                            size_t aTemplateStep, MppiSize aTemplateSize,
                                                            DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                                            Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the normalized squared distance.<para/>
    /// Note: in order to compute the common "full" or "same" variant as e.g. in NPP, set the input and output ROIs
    /// accordingly and use BorderType::Constant with aConstant = 0.
    /// </summary>
    MPPErrorCode mppciSquareDistanceNormalized_16s32f_C1R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                          MppiSize aSrcFullSize, ConstDevPtrMpp16s aTemplate,
                                                          size_t aTemplateStep, MppiSize aTemplateSize,
                                                          DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                                          MPPBorderType aBorder, MppiRect aSrcROI,
                                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the cross-correlation coefficient (CrossCorr_NormLevel in NPP).<para/>
    /// Note: in order to compute the common "full" or "same" variant as e.g. in NPP, set the input and output ROIs
    /// accordingly and use BorderType::Constant with aConstant = 0.
    /// </summary>
    MPPErrorCode mppciCrossCorrelationCoefficient_16s32f_C1RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp32f aSrcBoxFilteredBasePtr,
        size_t aSrcBoxFilteredStep, MppiSize aSrcFullSize, ConstDevPtrMpp16s aTemplate, size_t aTemplateStep,
        MppiSize aTemplateSize, ConstDevPtrMpp64f aMeanTemplate, DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
        Mpp16s aConstant, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the cross-correlation coefficient (CrossCorr_NormLevel in NPP).<para/>
    /// Note: in order to compute the common "full" or "same" variant as e.g. in NPP, set the input and output ROIs
    /// accordingly and use BorderType::Constant with aConstant = 0.
    /// </summary>
    MPPErrorCode mppciCrossCorrelationCoefficient_16s32f_C1R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp32f aSrcBoxFilteredBasePtr,
        size_t aSrcBoxFilteredStep, MppiSize aSrcFullSize, ConstDevPtrMpp16s aTemplate, size_t aTemplateStep,
        MppiSize aTemplateSize, ConstDevPtrMpp64f aMeanTemplate, DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCircularRadialProfile_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                   DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                   DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                   const Mpp32f aCenter[2], MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aRadiusRatio">Ratio of orientation axis to orthogonal axis. (i.e. 1.5 means stretched 1.5x)</param>
    /// <param name="aAngleInDeg">Orientation of the ellipse's orthogonal axis, clockwise in degrees with 0.0 being
    /// vertical.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciEllipticalRadialProfile_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                     DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                     DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                     const Mpp32f aCenter[2], Mpp32f aRadiusRatio, Mpp32f aAngleInDeg,
                                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, MPPCompareOp aCompare,
                                        DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                           MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThreshold_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aThreshold,
                                       MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                           MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aThreshold,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aThreshold,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThreshold_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aThreshold,
                                        MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                            MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aThreshold,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aThreshold,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aThreshold, Mpp16s aValue,
                                          MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aThreshold, Mpp16s aValue,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aThreshold, Mpp16s aValue,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aThreshold, Mpp16s aValue,
                                           MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aThreshold, Mpp16s aValue,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aThreshold, Mpp16s aValue,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aThresholdLT,
                                           Mpp16s aValueLT, Mpp16s aThresholdGT, Mpp16s aValueGT, DevPtrMpp16s aDst,
                                           size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aThresholdLT,
                                            Mpp16s aValueLT, Mpp16s aThresholdGT, Mpp16s aValueGT, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aSrc2 fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MPPCompareOp aCompare, Mpp16s aValue, DevPtrMpp16s aDst,
                                       size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aConst, MPPCompareOp aCompare,
                                        Mpp16s aValue, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                           MPPCompareOp aCompare, Mpp16s aValue, DevPtrMpp16s aDst, size_t aDstStep,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aSrc2 fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, MPPCompareOp aCompare, Mpp16s aValue, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, MPPCompareOp aCompare,
                                         Mpp16s aValue, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            MPPCompareOp aCompare, Mpp16s aValue, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                               size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                              size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                               MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Grayscale Color Filter Array to RGB Color Debayer conversion.<para/>
    /// Generates one RGB color pixel for every grayscale source pixel. Source and destination image ROIs must have even
    /// width and height. Missing pixel colors are generated using bilinear interpolation with chroma correlation of
    /// generated green values. aBayerGrid allows the user to specify the Bayer grid registration position at source
    /// image location oSrcROI.x, oSrcROI.y relative to pSrc.<para/> Possible registration positions are:<para/> BGGR,
    /// RGGB, GBRG, GRBG<para/> If it becomes necessary to access source pixels outside the aAllowedReadRoi then the
    /// source image borders are mirrored.
    /// </summary>
    MPPErrorCode mppciCFAToRGB_16s_C1C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MPPBayerGridPosition aBayerGrid, MppiRect aSrcROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Grayscale Color Filter Array to RGB Color Debayer conversion.<para/>
    /// Generates one RGB color pixel for every grayscale source pixel. Source and destination image ROIs must have even
    /// width and height. Missing pixel colors are generated using bilinear interpolation with chroma correlation of
    /// generated green values. aBayerGrid allows the user to specify the Bayer grid registration position at source
    /// image location oSrcROI.x, oSrcROI.y relative to pSrc.<para/> Possible registration positions are:<para/> BGGR,
    /// RGGB, GBRG, GRBG<para/> If it becomes necessary to access source pixels outside the aAllowedReadRoi then the
    /// source image borders are mirrored.<para/> The alpha channel (the last channel), is set to aAlpha.
    /// </summary>
    MPPErrorCode mppciCFAToRGB_16s_C1C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp16s aAlpha,
                                         MPPBayerGridPosition aBayerGrid, MppiRect aSrcROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion.<para/>
    /// aPalette must be an array of at least 2^aBitSize elements.<para/>
    /// aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        ConstDevPtrMpp16s aPalette, Mpp32s aBitSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion - inplace.<para/>
    /// aPalette must be an array of at least 2^aBitSize elements.<para/>
    /// aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aPalette,
                                         Mpp32s aBitSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion.<para/>
    /// aPalette must be an array of at least 2^aBitSize elements.<para/>
    /// aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPaletteC3_16s_C1C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, ConstDevPtrMpp16s aPalette, Mpp32s aBitSize,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion. One channel gray scale to 3 channel color. The palette is padded to 4
    /// channels where the last channel is not used.<para/> aPalette must be an array of at least 2^aBitSize
    /// elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPaletteAC4_16s_C1C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                             size_t aDstStep, ConstDevPtrMpp16s aPalette, Mpp32s aBitSize,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion. One channel gray scale to 3 channel color.<para/> aPalette must be an
    /// array of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPaletteC3_16s_C1AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                             size_t aDstStep, ConstDevPtrMpp16s aPalette, Mpp32s aBitSize,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion. One channel gray scale to 3 channel color.<para/> aPalette must be an
    /// array of at least 2^aBitSize elements. The palette is padded to 4 channels where the last channel is not
    /// used.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPaletteAC4_16s_C1AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                              size_t aDstStep, ConstDevPtrMpp16s aPalette, Mpp32s aBitSize,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion. One channel gray scale to 4 channel color.<para/> aPalette must be an
    /// array of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C1C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                          ConstDevPtrMpp16s aPalette, Mpp32s aBitSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrc1 source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the destination image aDst.
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, Mpp16s aColorKey, DevPtrMpp16s aDst, size_t aDstStep,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrcDst source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the same source image (inplace operation).
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_C1I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, Mpp16s aColorKey, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with mask. Pixels with mask == 0 remain untouched in destination image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                   ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy packed image pixels to planar images.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C2P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstChannel1,
                                    size_t aDstChannel1Step, DevPtrMpp16s aDstChannel2, size_t aDstChannel2Step,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy planar image pixels to packed pixel image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_P2C2(DevPtrMpp16s aSrcChannel1, size_t aSrcChannel1Step, DevPtrMpp16s aSrcChannel2,
                                    size_t aSrcChannel2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aBorder">Border control paramter</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    MPPErrorCode mppciCopyBorder_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        const Mpp32s aLowerBorderSize[2], MPPBorderType aBorder, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    /// <param name="aBorder">Border control paramter</param>
    MPPErrorCode mppciCopyBorder_16s_C2Cb(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                          const Mpp32s aLowerBorderSize[2], const Mpp16s aConstant[2],
                                          MPPBorderType aBorder, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy subpix.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aDelta">Fractional part of source image coordinate</param>
    /// <param name="aInterpolation">Interpolation mode to use</param>
    MPPErrorCode mppciCopySubpix_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        const Mpp32f aDelta[2], MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C2IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                    ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C2IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set channel aChannel of all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C2CI(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aChannel,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set channel aChannel of all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C2CI(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       Mpp32s aChannel, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Swap channels for two channel images.
    /// </summary>
    MPPErrorCode mppciSwapChannel_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Swap channels (inplace) for two channel images.
    /// </summary>
    MPPErrorCode mppciSwapChannel_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Transpose image.
    /// </summary>
    MPPErrorCode mppciTranspose_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                       MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInv_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInv_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MPPRoundingMode aRoundingMode, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                     MPPRoundingMode aRoundingMode, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C2Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                        MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                      Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInv_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_C2ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C2MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                       MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInv_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_C2IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                             MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_C2I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                           size_t aSrcDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                           size_t aSrcDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_C2I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C2I(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                             size_t aSrcDstStep, Mpp32f aAlpha, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C2IM(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                              size_t aSrcDstStep, Mpp32f aAlpha, ConstDevPtrMpp8u aMask,
                                              size_t aMaskStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = abs(aSrc1)
    /// </summary>
    MPPErrorCode mppciAbs_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = abs(aSrcDst)
    /// </summary>
    MPPErrorCode mppciAbs_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2], DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = ~aSrc1 (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = ~aSrcDst (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = exp(aSrc1) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = exp(aSrcDst) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = log(aSrc1) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = log(aSrcDst) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2], DevPtrMpp16s aDst,
                                 size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2], MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc1 (aSrc1^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst * aSrcDst (aSrcDst^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = Sqrt(aSrc1) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = Sqrt(aSrcDst) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2], DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aAlpha, DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aAlpha, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using alpha opacity values contained in each image. Last color channel is alpha channel, 1
    /// channel images are treated as alpha channel only.
    /// </summary>
    MPPErrorCode mppciAlphaComp_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MPPAlphaOp aAlphaOp,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using constant alpha values.
    /// </summary>
    MPPErrorCode mppciAlphaCompC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp16s aAlpha1,
                                        Mpp16s aAlpha2, MPPAlphaOp aAlphaOp, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst.real = aSrc1, aDst.imag = 0 (converts real valued image to complex with imaginary part = 0)
    /// </summary>
    MPPErrorCode mppciMakeComplex_16s16sc_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16sc aDst,
                                             size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst.real = aSrc1, aDst.imag = aSrcImag (converts two real valued images to one complex image)
    /// </summary>
    MPPErrorCode mppciMakeComplexImag_16s16sc_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrcImag,
                                                 size_t aSrcImagStep, DevPtrMpp16sc aDst, size_t aDstStep,
                                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            MPPFixedFilter aFilter, MPPMaskSize aMaskSize, const Mpp16s aConstant[2],
                                            MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, MPPFixedFilter aFilter,
                                          MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                               MPPFixedFilter aFilter, MPPMaskSize aMaskSize, const Mpp16s aConstant[2],
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MPPFixedFilter aFilter, MPPMaskSize aMaskSize, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                                const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                             const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                           MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                   MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                   Mpp32s aFilterCenter, const Mpp16s aConstant[2],
                                                   MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                 MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                 Mpp32s aFilterCenter, MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                          const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                                Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                                const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                              Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                             MppiFilterArea aFilterArea, const Mpp16s aConstant[2],
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Median filter (only filter sizes 3x3, 5x5 and 7x7 are implemented).
    /// </summary>
    MPPErrorCode mppciMedianFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MppiFilterArea aFilterArea, const Mpp32f aNoise[2],
                                             const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, const Mpp32f aNoise[2], MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                           MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                           MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                           const Mpp32f aDelta[2], const Mpp16s aValGT[2],
                                                           const Mpp16s aValLE[2], const Mpp16s aConstant[2],
                                                           MPPBorderType aBorder, MppiRect aSrcROI,
                                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                         MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                         MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                         const Mpp32f aDelta[2], const Mpp16s aValGT[2],
                                                         const Mpp16s aValLE[2], MPPBorderType aBorder,
                                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                       MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea,
                                          const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    /// <param name="aNorm">Norm to use when computing the pixel weight for multi-channel images.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                     MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                     MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                     ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                     MPPNorm aNorm, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    /// <param name="aNorm">Norm to use when computing the pixel weight for multi-channel images.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                   ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                   MPPNorm aNorm, MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                       MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
                                                       DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag,
                                                       size_t aDstMagStep, DevPtrMpp32f aDstAngle, size_t aDstAngleStep,
                                                       DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep,
                                                       MppiSize aDstSize, MPPNorm aNorm, MPPMaskSize aMaskSize,
                                                       const Mpp16s aConstant[2], MPPBorderType aBorder,
                                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_C2R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_C2RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_C2R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_C2RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_C2R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              Mpp32f aWeight, Mpp32f aThreshold, const Mpp16s aConstant[2],
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                            Mpp32f aWeight, Mpp32f aThreshold, MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                           const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                         MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_P2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                           ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                           MppiSize aDstSize, const Mpp64f aAffine[2][3],
                                           MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                           MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_P2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                         ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                         MppiSize aDstSize, const Mpp64f aAffine[2][3],
                                         MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                               const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to
    /// use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_P2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                               ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                               size_t aDst2Step, MppiSize aDstSize, const Mpp64f aAffine[2][3],
                                               MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to
    /// use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_P2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                             ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                             MppiSize aDstSize, const Mpp64f aAffine[2][3],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                                const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_P2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                                size_t aDst2Step, MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                                MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_P2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                              ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                              size_t aDst2Step, MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                              MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                              MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                    MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                    MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                    MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                                    MPPBorderType aBorder, MppiRect aSrcROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                  MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                  MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                                  MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_P2RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
        MppiSize aDstSize, const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
        const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_P2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                                  MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                  DevPtrMpp16s aDst2, size_t aDst2Step, MppiSize aDstSize,
                                                  const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                                  MPPBorderType aBorder, MppiRect aSrcROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                       const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                       const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                     const Mpp64f aShift[2], MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_P2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                       size_t aSrc2Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
                                       DevPtrMpp16s aDst2, size_t aDst2Step, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                       const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                       const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_P2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                     size_t aSrc2Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
                                     DevPtrMpp16s aDst2, size_t aDst2Step, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                     const Mpp64f aShift[2], MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize<para/>
    /// Simplified API to rescale from source image ROI to destination image ROI.<para/>
    /// NOTE: the result is NOT the same as in NPP using the same function. The shift applied in NPP for the same
    /// function don't make much sense to me, in MPP Resize matches the input extent [-0.5 .. srcWidth-0.5[ to the
    /// output [-0.5 .. dstWidth-0.5[. Whereas NPP applies different strategies for up-and downscaling. In order to get
    /// the same results as in NPP, use an user defined scaling factor of <para/> Vec2d scaleFactor =
    /// Vec2d(dstImg.SizeRoi()) / Vec2d(srcImg.SizeRoi());<para/> and a shift given by ResizeGetNPPShift().
    /// </summary>
    MPPErrorCode mppciResize_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize<para/>
    /// Simplified API to rescale from source image ROI to destination image ROI.<para/>
    /// NOTE: the result is NOT the same as in NPP using the same function. The shift applied in NPP for the same
    /// function don't make much sense to me, in MPP Resize matches the input extent [-0.5 .. srcWidth-0.5[ to the
    /// output [-0.5 .. dstWidth-0.5[. Whereas NPP applies different strategies for up-and downscaling. In order to get
    /// the same results as in NPP, use an user defined scaling factor of <para/> Vec2d scaleFactor =
    /// Vec2d(dstImg.SizeRoi()) / Vec2d(srcImg.SizeRoi());<para/> and a shift given by ResizeGetNPPShift().
    /// </summary>
    MPPErrorCode mppciResize_16s_P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                    size_t aDst2Step, MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aScale[2], const Mpp64f aShift[2],
                                               MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             const Mpp64f aScale[2], const Mpp64f aShift[2],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_P2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                               ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                               size_t aDst2Step, MppiSize aDstSize, const Mpp64f aScale[2],
                                               const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                               const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_P2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                             ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                             MppiSize aDstSize, const Mpp64f aScale[2], const Mpp64f aShift[2],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis
    /// </summary>
    MPPErrorCode mppciMirror_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    MPPMirrorAxis aAxis, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis (inplace operation)
    /// </summary>
    MPPErrorCode mppciMirror_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MPPMirrorAxis aAxis, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                        MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                      MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                      ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                      MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                    ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                    ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                    MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_P2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                        ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                        MppiSize aDstSize, ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                        MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_P2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                      size_t aSrc2Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
                                      DevPtrMpp16s aDst2, size_t aDst2Step, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                      MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_P2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                      size_t aSrc2Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
                                      DevPtrMpp16s aDst2, size_t aDst2Step, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                      ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                      MPPInterpolationMode aInterpolation, const Mpp16s aConstant[2],
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_P2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                    size_t aSrc2Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
                                    DevPtrMpp16s aDst2, size_t aDst2Step, MppiSize aDstSize,
                                    ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                    ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                    MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, MppiFilterArea aFilterArea,
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                            const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                          MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea,
                                            const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                             const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea,
                                             const Mpp16s aConstant[2], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                   DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                   DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                   MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                      MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                      MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                    MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                         MppiFilterArea aFilterArea, const Mpp16s aConstant[2], MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_C2RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                                   MppiFilterArea aFilterArea, const Mpp16s aConstant[2],
                                                   MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_C2R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                 MppiSize aDstSize, ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                                 MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/> For multi-channel images, the result is computed for each channel seperatly in
    /// aDst, or for all channels in aDstScalar. <para/> If the image is in complex format, the absolute value is used
    /// for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProduct.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProductMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j)) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j)) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSE.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSEMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer,
                                    size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/> For multi-channel images, the result is computed for each channel
    /// seperatly in aDst, or for all channels in aDstScalar. <para/> If the image is in complex format, the absolute
    /// value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm of difference of pixels between two images.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm of difference of pixels between two images.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm of difference of pixels between two images.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative infinity norm of difference of pixels between two images.<para/>
    /// The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) / NormInf(Src2)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative infinity norm of difference of pixels between two images where only pixels with mask != 0
    /// are used.<para/> The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) /
    /// NormInf(Src2)<para/> For multi-channel images, the result is computed for each channel seperatly in aDst, or for
    /// all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L1 norm of difference of pixels between two images.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                          DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L1 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                           size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L2 norm of difference of pixels between two images.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                          DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L2 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                           size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for PSNR.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciPSNRBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the PSNR of two images. <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aValueRange">The maximum possible pixel value, eg. 255 for 8 bit unsigned int images,
    /// 4095 for 12-bit unsigned images, etc.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciPSNR_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar, Mpp64f aValueRange,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                         DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                    DevPtrMpp64s aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                    DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                     DevPtrMpp64s aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                     DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Mean.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                     DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStd.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStdMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aMean">Per-channel mean value, can be nullptr if aStd is also nullptr</param>
    /// <param name="aStd">Per-channel standard deviation value, can be nullptr if aMean is also nullptr</param>
    /// <param name="aMeanScalar">Mean value for all channels, can be nullptr if aStdScalar is also nullptr</param>
    /// <param name="aStdScalar">Standard deviation for all channels, can be nullptr if aMeanScalar is also
    /// nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                     DevPtrMpp64f aMeanScalar, DevPtrMpp64f aStdScalar, DevPtrMpp8u aBuffer,
                                     size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values where only pixels with mask != 0 are used.<para/>For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aMean">Per-channel mean value, can be nullptr if aStd is also nullptr</param>
    /// <param name="aStd">Per-channel standard deviation value, can be nullptr if aMean is also nullptr</param>
    /// <param name="aMeanScalar">Mean value for all channels, can be nullptr if aStdScalar is also nullptr</param>
    /// <param name="aStdScalar">Standard deviation for all channels, can be nullptr if aMeanScalar is also
    /// nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                      DevPtrMpp64f aMeanScalar, DevPtrMpp64f aStdScalar, ConstDevPtrMpp8u aMask,
                                      size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRangeMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aLowerLimit[2],
                                             const Mpp16s aUpperLimit[2], DevPtrMpp64u aDst, DevPtrMpp64u aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range where only pixels with mask != 0 are used.<para/>For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aLowerLimit[2],
                                              const Mpp16s aUpperLimit[2], DevPtrMpp64u aDst, DevPtrMpp64u aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the image quality index of two images. This implementation is identical to the one in NPP computing a
    /// global index without a sliding window.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndex_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndexWindow.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexWindowBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the QualityIndex of two images. This function is implemented using a sliding window approach as is done
    /// in the original paper / code with a window size of 11x11 pixels.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndexWindow_16s32f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                   size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer,
                                                   size_t aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSSIMBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically this is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSSIM_16s32f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSSSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSSSIMBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Multi-Scale-SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically aSrc1 is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSSSIM_16s32f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Min.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value.
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                 DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value where only pixels with mask != 0 are used.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                  ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Max.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value.
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                 DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value where only pixels with mask != 0 are used.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                  ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMax.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value.<para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax, or for all
    /// channels in aDstMinScalar/aDstMaxScalar.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstMax is also nullptr</param>
    /// <param name="aDstMax">Per-channel maximum value, can be nullptr if aDstMin is also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr if aDstMaxScalar also nullptr</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels, can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                    DevPtrMpp16s aDstMax, DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                    DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value where only pixels with mask != 0 are used.<para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax, or for all
    /// channels in aDstMinScalar/aDstMaxScalar.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstMax is also nullptr</param>
    /// <param name="aDstMax">Per-channel maximum value, can be nullptr if aDstMin is also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr if aDstMaxScalar also nullptr</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels, can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                     DevPtrMpp16s aDstMax, DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is computed for each
    /// channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the minimum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                      DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMinScalar,
                                      DevPtrMpp32s aDstScalarIdx, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels
    /// in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the minimum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                       DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMinScalar,
                                       DevPtrMpp32s aDstScalarIdx, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is computed for each
    /// channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel maximum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Maximum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the maximum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                      DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMaxScalar,
                                      DevPtrMpp32s aDstScalarIdx, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels
    /// in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel maximum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Maximum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the maximum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                       DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMaxScalar,
                                       DevPtrMpp32s aDstScalarIdx, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_C2M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices. For multiple occurences of the same value the index
    /// with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is
    /// computed for each channel seperatly in aDstMin/aDstMax/aDstIdx, or for all channels in
    /// aDstMinScalar/aDstMaxScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Minimum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMax and aDstIdx are also nullptr.</param>
    /// <param name="aDstMax">Maximum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstIdx are also nullptr.</param>
    /// <param name="aDstIdx">Pixel index for min and max value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstMax are also nullptr.</param>
    /// <param name="aDstMinScalar">Minimum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMaxScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstScalarIdx">Pixel index for min and max value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstMaxScalar are also nullptr.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                         DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx,
                                         DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                         DevPtrMppiIndexMinMaxChannel aDstScalarIdx, DevPtrMpp8u aBuffer,
                                         size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices where only pixels with mask != 0 are used. For multiple
    /// occurences of the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax/aDstIdx, or for all
    /// channels in aDstMinScalar/aDstMaxScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Minimum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMax and aDstIdx are also nullptr.</param>
    /// <param name="aDstMax">Maximum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstIdx are also nullptr.</param>
    /// <param name="aDstIdx">Pixel index for min and max value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstMax are also nullptr.</param>
    /// <param name="aDstMinScalar">Minimum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMaxScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstScalarIdx">Pixel index for min and max value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstMaxScalar are also nullptr.</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_C2M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                          DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx,
                                          DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                          DevPtrMppiIndexMinMaxChannel aDstScalarIdx, ConstDevPtrMpp8u aMask,
                                          size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s32s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s32f_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s64s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s64f_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32s32s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32s64s_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32f64f_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s64f64f_C2(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s32s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst, size_t aDstStep,
                                         const Mpp32s aVal[2], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s32f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aDst, size_t aDstStep,
                                         const Mpp32f aVal[2], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s64s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst, size_t aDstStep,
                                         const Mpp64s aVal[2], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst, size_t aDstStep,
                                         const Mpp64f aVal[2], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32s32s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst,
                                               size_t aDstStep, DevPtrMpp32s aSqr, size_t aSqrStep,
                                               const Mpp32s aVal[2], const Mpp32s aValSqr[2], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32s64s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst,
                                               size_t aDstStep, DevPtrMpp64s aSqr, size_t aSqrStep,
                                               const Mpp32s aVal[2], const Mpp64s aValSqr[2], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32f64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aDst,
                                               size_t aDstStep, DevPtrMpp64f aSqr, size_t aSqrStep,
                                               const Mpp32f aVal[2], const Mpp64f aValSqr[2], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s64f64f_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                               size_t aDstStep, DevPtrMpp64f aSqr, size_t aSqrStep,
                                               const Mpp64f aVal[2], const Mpp64f aValSqr[2], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = min(aSrc1, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = min(aSrcDst, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = max(aSrc1, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = max(aSrcDst, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramEven.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramEvenBufferSize_16s_C2(size_t *aBufferSize, const Mpp32s aNumLevels[2], MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The aLowerLevel (inclusive) and aUpperLevel (exclusive) define the boundaries of the range,
    /// which are evenly segmented into aHist.Size() bins.
    /// </summary>
    /// <param name="aHist">host array of device memory pointers to the computed histograms
    /// (one for each active channel). The size of aHist[channel] gives the number of bins used.</param>
    /// <param name="aLowerLevel">lower level (inclusive, per channel)</param>
    /// <param name="aUpperLevel">upper level (exclusive, per channel)</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramEven_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist[2],
                                           const Mpp32s aLowerLevel[2], const Mpp32s aUpperLevel[2],
                                           Mpp32s aNumLevels[2], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramRangeBufferSize_16s_C2(size_t *aBufferSize, const Mpp32s aNumLevels[2],
                                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the histogram of an image within specified ranges.
    /// </summary>
    /// <param name="aHist">host array of device memory pointers to the computed histograms
    /// (one for each active channel). The size of aHist[channel] gives the number of bins used.</param>
    /// <param name="aLevels">host array of device memory pointers to the array
    /// with the range defintions, one array per channel. The levels array must be one element
    /// larger than the histogram array, as number of levels = number of bins + 1.</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramRange_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist[2],
                                            ConstDevPtrMpp32s aLevels[2], Mpp32s aNumLevels[2], DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCircularRadialProfile_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                   DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                   DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                   const Mpp32f aCenter[2], MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aRadiusRatio">Ratio of orientation axis to orthogonal axis. (i.e. 1.5 means stretched 1.5x)</param>
    /// <param name="aAngleInDeg">Orientation of the ellipse's orthogonal axis, clockwise in degrees with 0.0 being
    /// vertical.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciEllipticalRadialProfile_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                     DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                     DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                     const Mpp32f aCenter[2], Mpp32f aRadiusRatio, Mpp32f aAngleInDeg,
                                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_C2C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_C2C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                          MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_C2C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                             MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                        MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                           MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThreshold_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[2],
                                       MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                           MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[2],
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[2],
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThreshold_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[2],
                                        MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                            MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[2],
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[2],
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[2],
                                          const Mpp16s aValue[2], MPPCompareOp aCompare, DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[2],
                                            const Mpp16s aValue[2], DevPtrMpp16s aDst, size_t aDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[2],
                                            const Mpp16s aValue[2], DevPtrMpp16s aDst, size_t aDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[2],
                                           const Mpp16s aValue[2], MPPCompareOp aCompare, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[2],
                                             const Mpp16s aValue[2], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[2],
                                             const Mpp16s aValue[2], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThresholdLT[2],
                                           const Mpp16s aValueLT[2], const Mpp16s aThresholdGT[2],
                                           const Mpp16s aValueGT[2], DevPtrMpp16s aDst, size_t aDstStep,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThresholdLT[2],
                                            const Mpp16s aValueLT[2], const Mpp16s aThresholdGT[2],
                                            const Mpp16s aValueGT[2], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aSrc2 fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MPPCompareOp aCompare, const Mpp16s aValue[2],
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[2],
                                        MPPCompareOp aCompare, const Mpp16s aValue[2], DevPtrMpp16s aDst,
                                        size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                           MPPCompareOp aCompare, const Mpp16s aValue[2], DevPtrMpp16s aDst,
                                           size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aSrc2 fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, MPPCompareOp aCompare, const Mpp16s aValue[2],
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[2],
                                         MPPCompareOp aCompare, const Mpp16s aValue[2], MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            MPPCompareOp aCompare, const Mpp16s aValue[2], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From422_16s_C2C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, const Mpp32f aTwist[3][3], bool aSwapLumaChroma,
                                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From422_16s_C2P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                                    size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                                    DevPtrMpp16s aDst3, size_t aDst3Step, const Mpp32f aTwist[3][3],
                                                    bool aSwapLumaChroma, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From422_16s_C2C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, const Mpp32f aTwist[3][4], bool aSwapLumaChroma,
                                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From422_16s_C2P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                                    size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                                    DevPtrMpp16s aDst3, size_t aDst3Step, const Mpp32f aTwist[3][4],
                                                    bool aSwapLumaChroma, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_P2(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aSrc2, size_t aSrc2Step,
                                            DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                            Mpp32f aNormFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                               size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_P2(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aSrc2,
                                               size_t aSrc2Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                               DevPtrMpp16s aDst2, size_t aDst2Step, Mpp32f aNormFactor,
                                               MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_P2(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aSrc2, size_t aSrc2Step,
                                           DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                           Mpp32f aNormFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                              size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_P2(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                              DevPtrMpp16s aDst2, size_t aDst2Step, Mpp32f aNormFactor,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                               MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a color gradient image to grayscale.
    /// </summary>
    MPPErrorCode mppciGradientColorToGray_16s_C2C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                                   size_t aDstStep, MPPNorm aNorm, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a color gradient image to grayscale.
    /// </summary>
    MPPErrorCode mppciGradientColorToGray_16s_P2C1(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aSrc2,
                                                   size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MPPNorm aNorm,
                                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a multi-channel color image to a one channel gray scale image where each channel is weighted by the
    /// factor provided in aWeights.<para/> Common values to convert RGB to gray are nGray = 0.299 * R + 0.587 * G +
    /// 0.114 * B
    /// </summary>
    MPPErrorCode mppciColorToGray_16s_C2C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, const Mpp32f aWeights[2], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a multi-channel color image to a one channel gray scale image where each channel is weighted by the
    /// factor provided in aWeights.<para/> Common values to convert RGB to gray are nGray = 0.299 * R + 0.587 * G +
    /// 0.114 * B
    /// </summary>
    MPPErrorCode mppciColorToGray_16s_P2C1(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aSrc2, size_t aSrc2Step,
                                           DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aWeights[2],
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion.<para/> aPalette is a pointer to number of color channels
    /// arrays of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        ConstDevPtrMpp16s aPalette[2], Mpp32s aBitSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion - inplace.<para/> aPalette is a pointer to number of color channels
    /// arrays of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aPalette[2],
                                         Mpp32s aBitSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrc1 source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the destination image aDst.
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, const Mpp16s aColorKey[2], DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrcDst source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the same source image (inplace operation).
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_C2I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, const Mpp16s aColorKey[2], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts from packed C2 422 sampling to planar P2 422 sampling.
    /// </summary>
    /// <param name="aSwapLumaChroma">Set to false if input is in format YCbCr, true for CbYCr.</param>
    MPPErrorCode mppciConvertSampling422_16s_C2P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                  bool aSwapLumaChroma, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts from packed C2 422 sampling to planar P3 422 sampling.
    /// </summary>
    /// <param name="aSwapLumaChroma">Set to false if input is in format YCbCr, true for CbYCr.</param>
    MPPErrorCode mppciConvertSampling422_16s_C2P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma1, size_t aDstChroma1Step,
                                                  DevPtrMpp16s aDstChroma2, size_t aDstChroma2Step,
                                                  bool aSwapLumaChroma, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with mask. Pixels with mask == 0 remain untouched in destination image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                   ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy packed image pixels to planar images.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstChannel1,
                                    size_t aDstChannel1Step, DevPtrMpp16s aDstChannel2, size_t aDstChannel2Step,
                                    DevPtrMpp16s aDstChannel3, size_t aDstChannel3Step, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy planar image pixels to packed pixel image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_P3C3(DevPtrMpp16s aSrcChannel1, size_t aSrcChannel1Step, DevPtrMpp16s aSrcChannel2,
                                    size_t aSrcChannel2Step, DevPtrMpp16s aSrcChannel3, size_t aSrcChannel3Step,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aBorder">Border control paramter</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    MPPErrorCode mppciCopyBorder_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        const Mpp32s aLowerBorderSize[2], MPPBorderType aBorder, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    /// <param name="aBorder">Border control paramter</param>
    MPPErrorCode mppciCopyBorder_16s_C3Cb(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                          const Mpp32s aLowerBorderSize[2], const Mpp16s aConstant[3],
                                          MPPBorderType aBorder, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy subpix.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aDelta">Fractional part of source image coordinate</param>
    /// <param name="aInterpolation">Interpolation mode to use</param>
    MPPErrorCode mppciCopySubpix_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        const Mpp32f aDelta[2], MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C3IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                    ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C3IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set channel aChannel of all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C3CI(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aChannel,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set channel aChannel of all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C3CI(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       Mpp32s aChannel, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Swap channels (inplace)<para/>
    /// aDstChannels describes how channel values are permutated. The n-th entry
    /// of the array contains the number of the channel that is stored in the n-th channel of
    /// the output image. <para/>
    /// E.g. Given an RGB image, aDstChannels = [2,1,0] converts aSrcDst to BGR channel order.
    /// </summary>
    MPPErrorCode mppciSwapChannel_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp32s aDstChannels[3],
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Transpose image.
    /// </summary>
    MPPErrorCode mppciTranspose_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                       MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInv_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInv_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MPPRoundingMode aRoundingMode, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                     MPPRoundingMode aRoundingMode, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C3Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                        MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                      Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInv_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_C3ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C3MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                       MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInv_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_C3IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                             MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_C3I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                           size_t aSrcDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                           size_t aSrcDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_C3I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C3I(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                             size_t aSrcDstStep, Mpp32f aAlpha, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C3IM(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                              size_t aSrcDstStep, Mpp32f aAlpha, ConstDevPtrMpp8u aMask,
                                              size_t aMaskStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = abs(aSrc1)
    /// </summary>
    MPPErrorCode mppciAbs_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = abs(aSrcDst)
    /// </summary>
    MPPErrorCode mppciAbs_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3], DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = ~aSrc1 (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = ~aSrcDst (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = exp(aSrc1) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = exp(aSrcDst) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = log(aSrc1) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = log(aSrcDst) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3], DevPtrMpp16s aDst,
                                 size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3], MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc1 (aSrc1^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst * aSrcDst (aSrcDst^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = Sqrt(aSrc1) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = Sqrt(aSrcDst) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3], DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aAlpha, DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aAlpha, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using alpha opacity values contained in each image. Last color channel is alpha channel, 1
    /// channel images are treated as alpha channel only.
    /// </summary>
    MPPErrorCode mppciAlphaComp_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MPPAlphaOp aAlphaOp,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using constant alpha values.
    /// </summary>
    MPPErrorCode mppciAlphaCompC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp16s aAlpha1,
                                        Mpp16s aAlpha2, MPPAlphaOp aAlphaOp, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst.real = aSrc1, aDst.imag = 0 (converts real valued image to complex with imaginary part = 0)
    /// </summary>
    MPPErrorCode mppciMakeComplex_16s16sc_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16sc aDst,
                                             size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst.real = aSrc1, aDst.imag = aSrcImag (converts two real valued images to one complex image)
    /// </summary>
    MPPErrorCode mppciMakeComplexImag_16s16sc_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrcImag,
                                                 size_t aSrcImagStep, DevPtrMpp16sc aDst, size_t aDstStep,
                                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            MPPFixedFilter aFilter, MPPMaskSize aMaskSize, const Mpp16s aConstant[3],
                                            MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, MPPFixedFilter aFilter,
                                          MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                               MPPFixedFilter aFilter, MPPMaskSize aMaskSize, const Mpp16s aConstant[3],
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MPPFixedFilter aFilter, MPPMaskSize aMaskSize, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                                const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                             const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                           MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                   MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                   Mpp32s aFilterCenter, const Mpp16s aConstant[3],
                                                   MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                 MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                 Mpp32s aFilterCenter, MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                          const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                                Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                                const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                              Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                             MppiFilterArea aFilterArea, const Mpp16s aConstant[3],
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Median filter (only filter sizes 3x3, 5x5 and 7x7 are implemented).
    /// </summary>
    MPPErrorCode mppciMedianFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MppiFilterArea aFilterArea, const Mpp32f aNoise[3],
                                             const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, const Mpp32f aNoise[3], MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                           MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                           MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                           const Mpp32f aDelta[3], const Mpp16s aValGT[3],
                                                           const Mpp16s aValLE[3], const Mpp16s aConstant[3],
                                                           MPPBorderType aBorder, MppiRect aSrcROI,
                                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                         MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                         MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                         const Mpp32f aDelta[3], const Mpp16s aValGT[3],
                                                         const Mpp16s aValLE[3], MPPBorderType aBorder,
                                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                       MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea,
                                          const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    /// <param name="aNorm">Norm to use when computing the pixel weight for multi-channel images.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                     MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                     MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                     ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                     MPPNorm aNorm, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    /// <param name="aNorm">Norm to use when computing the pixel weight for multi-channel images.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                   ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                   MPPNorm aNorm, MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                       MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
                                                       DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag,
                                                       size_t aDstMagStep, DevPtrMpp32f aDstAngle, size_t aDstAngleStep,
                                                       DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep,
                                                       MppiSize aDstSize, MPPNorm aNorm, MPPMaskSize aMaskSize,
                                                       const Mpp16s aConstant[3], MPPBorderType aBorder,
                                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_C3R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_C3RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_C3R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_C3RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_C3R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              Mpp32f aWeight, Mpp32f aThreshold, const Mpp16s aConstant[3],
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                            Mpp32f aWeight, Mpp32f aThreshold, MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                           const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                         MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_P3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                           ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                           ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                           DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                           const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                           const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_P3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                         ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                         ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                         DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                         const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                         MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                               const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to
    /// use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_P3RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
        DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
        const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to
    /// use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_P3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                             ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                             ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                             DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                             const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                                const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_P3RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
        DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
        const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_P3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                              ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                              ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                              size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                              const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                    MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                    MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                    MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                                    MPPBorderType aBorder, MppiRect aSrcROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                  MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                  MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                                  MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_P3RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
        DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
        const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_P3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                                  ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                                  MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                  DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                  size_t aDst3Step, MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                  MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                                  MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                       const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                       const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                     const Mpp64f aShift[2], MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_P3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                       size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                       MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                       size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                       Mpp64f aAngleInDeg, const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                       const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_P3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                     size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                     MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                     size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                     Mpp64f aAngleInDeg, const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                     MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize<para/>
    /// Simplified API to rescale from source image ROI to destination image ROI.<para/>
    /// NOTE: the result is NOT the same as in NPP using the same function. The shift applied in NPP for the same
    /// function don't make much sense to me, in MPP Resize matches the input extent [-0.5 .. srcWidth-0.5[ to the
    /// output [-0.5 .. dstWidth-0.5[. Whereas NPP applies different strategies for up-and downscaling. In order to get
    /// the same results as in NPP, use an user defined scaling factor of <para/> Vec2d scaleFactor =
    /// Vec2d(dstImg.SizeRoi()) / Vec2d(srcImg.SizeRoi());<para/> and a shift given by ResizeGetNPPShift().
    /// </summary>
    MPPErrorCode mppciResize_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize<para/>
    /// Simplified API to rescale from source image ROI to destination image ROI.<para/>
    /// NOTE: the result is NOT the same as in NPP using the same function. The shift applied in NPP for the same
    /// function don't make much sense to me, in MPP Resize matches the input extent [-0.5 .. srcWidth-0.5[ to the
    /// output [-0.5 .. dstWidth-0.5[. Whereas NPP applies different strategies for up-and downscaling. In order to get
    /// the same results as in NPP, use an user defined scaling factor of <para/> Vec2d scaleFactor =
    /// Vec2d(dstImg.SizeRoi()) / Vec2d(srcImg.SizeRoi());<para/> and a shift given by ResizeGetNPPShift().
    /// </summary>
    MPPErrorCode mppciResize_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step, DevPtrMpp16s aDst1,
                                    size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                    size_t aDst3Step, MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aScale[2], const Mpp64f aShift[2],
                                               MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             const Mpp64f aScale[2], const Mpp64f aShift[2],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_P3RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step,
        DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
        const Mpp64f aScale[2], const Mpp64f aShift[2], MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_P3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                             ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                             ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                             DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                             const Mpp64f aScale[2], const Mpp64f aShift[2],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis
    /// </summary>
    MPPErrorCode mppciMirror_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    MPPMirrorAxis aAxis, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis (inplace operation)
    /// </summary>
    MPPErrorCode mppciMirror_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MPPMirrorAxis aAxis, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                        MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                      MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                      ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                      MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                    ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                    ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                    MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_P3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                        ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                        DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                        MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_P3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                      size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                      MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                      size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                      MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_P3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                      size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                      MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                      size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                      ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                      MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_P3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                    size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                    MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                    size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step, MppiSize aDstSize,
                                    ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                    ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                    MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, MppiFilterArea aFilterArea,
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                            const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                          MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea,
                                            const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                             const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea,
                                             const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                   DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                   DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                   MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                      MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                      MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                    MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                         MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_C3RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                                   MppiFilterArea aFilterArea, const Mpp16s aConstant[3],
                                                   MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_C3R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                 MppiSize aDstSize, ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                                 MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/> For multi-channel images, the result is computed for each channel seperatly in
    /// aDst, or for all channels in aDstScalar. <para/> If the image is in complex format, the absolute value is used
    /// for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProduct.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProductMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j)) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j)) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSE.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSEMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer,
                                    size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/> For multi-channel images, the result is computed for each channel
    /// seperatly in aDst, or for all channels in aDstScalar. <para/> If the image is in complex format, the absolute
    /// value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm of difference of pixels between two images.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm of difference of pixels between two images.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm of difference of pixels between two images.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative infinity norm of difference of pixels between two images.<para/>
    /// The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) / NormInf(Src2)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative infinity norm of difference of pixels between two images where only pixels with mask != 0
    /// are used.<para/> The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) /
    /// NormInf(Src2)<para/> For multi-channel images, the result is computed for each channel seperatly in aDst, or for
    /// all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L1 norm of difference of pixels between two images.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                          DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L1 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                           size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L2 norm of difference of pixels between two images.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                          DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L2 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                           size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for PSNR.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciPSNRBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the PSNR of two images. <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aValueRange">The maximum possible pixel value, eg. 255 for 8 bit unsigned int images,
    /// 4095 for 12-bit unsigned images, etc.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciPSNR_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar, Mpp64f aValueRange,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                         DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                    DevPtrMpp64s aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                    DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                     DevPtrMpp64s aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                     DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Mean.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                     DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStd.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStdMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aMean">Per-channel mean value, can be nullptr if aStd is also nullptr</param>
    /// <param name="aStd">Per-channel standard deviation value, can be nullptr if aMean is also nullptr</param>
    /// <param name="aMeanScalar">Mean value for all channels, can be nullptr if aStdScalar is also nullptr</param>
    /// <param name="aStdScalar">Standard deviation for all channels, can be nullptr if aMeanScalar is also
    /// nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                     DevPtrMpp64f aMeanScalar, DevPtrMpp64f aStdScalar, DevPtrMpp8u aBuffer,
                                     size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values where only pixels with mask != 0 are used.<para/>For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aMean">Per-channel mean value, can be nullptr if aStd is also nullptr</param>
    /// <param name="aStd">Per-channel standard deviation value, can be nullptr if aMean is also nullptr</param>
    /// <param name="aMeanScalar">Mean value for all channels, can be nullptr if aStdScalar is also nullptr</param>
    /// <param name="aStdScalar">Standard deviation for all channels, can be nullptr if aMeanScalar is also
    /// nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                      DevPtrMpp64f aMeanScalar, DevPtrMpp64f aStdScalar, ConstDevPtrMpp8u aMask,
                                      size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRangeMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aLowerLimit[3],
                                             const Mpp16s aUpperLimit[3], DevPtrMpp64u aDst, DevPtrMpp64u aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range where only pixels with mask != 0 are used.<para/>For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aLowerLimit[3],
                                              const Mpp16s aUpperLimit[3], DevPtrMpp64u aDst, DevPtrMpp64u aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the image quality index of two images. This implementation is identical to the one in NPP computing a
    /// global index without a sliding window.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndex_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndexWindow.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexWindowBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the QualityIndex of two images. This function is implemented using a sliding window approach as is done
    /// in the original paper / code with a window size of 11x11 pixels.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndexWindow_16s32f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                   size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer,
                                                   size_t aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSSIMBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically this is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSSIM_16s32f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSSSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSSSIMBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Multi-Scale-SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically aSrc1 is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSSSIM_16s32f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Min.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value.
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                 DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value where only pixels with mask != 0 are used.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                  ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Max.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value.
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                 DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value where only pixels with mask != 0 are used.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                  ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMax.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value.<para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax, or for all
    /// channels in aDstMinScalar/aDstMaxScalar.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstMax is also nullptr</param>
    /// <param name="aDstMax">Per-channel maximum value, can be nullptr if aDstMin is also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr if aDstMaxScalar also nullptr</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels, can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                    DevPtrMpp16s aDstMax, DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                    DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value where only pixels with mask != 0 are used.<para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax, or for all
    /// channels in aDstMinScalar/aDstMaxScalar.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstMax is also nullptr</param>
    /// <param name="aDstMax">Per-channel maximum value, can be nullptr if aDstMin is also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr if aDstMaxScalar also nullptr</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels, can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                     DevPtrMpp16s aDstMax, DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is computed for each
    /// channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the minimum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                      DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMinScalar,
                                      DevPtrMpp32s aDstScalarIdx, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels
    /// in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the minimum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                       DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMinScalar,
                                       DevPtrMpp32s aDstScalarIdx, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is computed for each
    /// channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel maximum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Maximum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the maximum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                      DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMaxScalar,
                                      DevPtrMpp32s aDstScalarIdx, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels
    /// in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel maximum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Maximum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the maximum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                       DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMaxScalar,
                                       DevPtrMpp32s aDstScalarIdx, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_C3M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices. For multiple occurences of the same value the index
    /// with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is
    /// computed for each channel seperatly in aDstMin/aDstMax/aDstIdx, or for all channels in
    /// aDstMinScalar/aDstMaxScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Minimum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMax and aDstIdx are also nullptr.</param>
    /// <param name="aDstMax">Maximum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstIdx are also nullptr.</param>
    /// <param name="aDstIdx">Pixel index for min and max value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstMax are also nullptr.</param>
    /// <param name="aDstMinScalar">Minimum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMaxScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstScalarIdx">Pixel index for min and max value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstMaxScalar are also nullptr.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                         DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx,
                                         DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                         DevPtrMppiIndexMinMaxChannel aDstScalarIdx, DevPtrMpp8u aBuffer,
                                         size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices where only pixels with mask != 0 are used. For multiple
    /// occurences of the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax/aDstIdx, or for all
    /// channels in aDstMinScalar/aDstMaxScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Minimum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMax and aDstIdx are also nullptr.</param>
    /// <param name="aDstMax">Maximum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstIdx are also nullptr.</param>
    /// <param name="aDstIdx">Pixel index for min and max value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstMax are also nullptr.</param>
    /// <param name="aDstMinScalar">Minimum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMaxScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstScalarIdx">Pixel index for min and max value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstMaxScalar are also nullptr.</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_C3M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                          DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx,
                                          DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                          DevPtrMppiIndexMinMaxChannel aDstScalarIdx, ConstDevPtrMpp8u aMask,
                                          size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s32s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s32f_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s64s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s64f_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32s32s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32s64s_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32f64f_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s64f64f_C3(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s32s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst, size_t aDstStep,
                                         const Mpp32s aVal[3], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s32f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aDst, size_t aDstStep,
                                         const Mpp32f aVal[3], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s64s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst, size_t aDstStep,
                                         const Mpp64s aVal[3], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst, size_t aDstStep,
                                         const Mpp64f aVal[3], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32s32s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst,
                                               size_t aDstStep, DevPtrMpp32s aSqr, size_t aSqrStep,
                                               const Mpp32s aVal[3], const Mpp32s aValSqr[3], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32s64s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst,
                                               size_t aDstStep, DevPtrMpp64s aSqr, size_t aSqrStep,
                                               const Mpp32s aVal[3], const Mpp64s aValSqr[3], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32f64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aDst,
                                               size_t aDstStep, DevPtrMpp64f aSqr, size_t aSqrStep,
                                               const Mpp32f aVal[3], const Mpp64f aValSqr[3], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s64f64f_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                               size_t aDstStep, DevPtrMpp64f aSqr, size_t aSqrStep,
                                               const Mpp64f aVal[3], const Mpp64f aValSqr[3], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = min(aSrc1, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = min(aSrcDst, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = max(aSrc1, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = max(aSrcDst, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramEven.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramEvenBufferSize_16s_C3(size_t *aBufferSize, const Mpp32s aNumLevels[3], MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The aLowerLevel (inclusive) and aUpperLevel (exclusive) define the boundaries of the range,
    /// which are evenly segmented into aHist.Size() bins.
    /// </summary>
    /// <param name="aHist">host array of device memory pointers to the computed histograms
    /// (one for each active channel). The size of aHist[channel] gives the number of bins used.</param>
    /// <param name="aLowerLevel">lower level (inclusive, per channel)</param>
    /// <param name="aUpperLevel">upper level (exclusive, per channel)</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramEven_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist[3],
                                           const Mpp32s aLowerLevel[3], const Mpp32s aUpperLevel[3],
                                           Mpp32s aNumLevels[3], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramRangeBufferSize_16s_C3(size_t *aBufferSize, const Mpp32s aNumLevels[3],
                                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the histogram of an image within specified ranges.
    /// </summary>
    /// <param name="aHist">host array of device memory pointers to the computed histograms
    /// (one for each active channel). The size of aHist[channel] gives the number of bins used.</param>
    /// <param name="aLevels">host array of device memory pointers to the array
    /// with the range defintions, one array per channel. The levels array must be one element
    /// larger than the histogram array, as number of levels = number of bins + 1.</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramRange_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist[3],
                                            ConstDevPtrMpp32s aLevels[3], Mpp32s aNumLevels[3], DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCircularRadialProfile_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                   DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                   DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                   const Mpp32f aCenter[2], MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aRadiusRatio">Ratio of orientation axis to orthogonal axis. (i.e. 1.5 means stretched 1.5x)</param>
    /// <param name="aAngleInDeg">Orientation of the ellipse's orthogonal axis, clockwise in degrees with 0.0 being
    /// vertical.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciEllipticalRadialProfile_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                     DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                     DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                     const Mpp32f aCenter[2], Mpp32f aRadiusRatio, Mpp32f aAngleInDeg,
                                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_C3C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_C3C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                          MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_C3C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                             MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                        MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                           MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThreshold_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                       MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                           MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThreshold_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                        MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                            MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                          const Mpp16s aValue[3], MPPCompareOp aCompare, DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                            const Mpp16s aValue[3], DevPtrMpp16s aDst, size_t aDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                            const Mpp16s aValue[3], DevPtrMpp16s aDst, size_t aDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                           const Mpp16s aValue[3], MPPCompareOp aCompare, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                             const Mpp16s aValue[3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                             const Mpp16s aValue[3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThresholdLT[3],
                                           const Mpp16s aValueLT[3], const Mpp16s aThresholdGT[3],
                                           const Mpp16s aValueGT[3], DevPtrMpp16s aDst, size_t aDstStep,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThresholdLT[3],
                                            const Mpp16s aValueLT[3], const Mpp16s aThresholdGT[3],
                                            const Mpp16s aValueGT[3], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aSrc2 fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MPPCompareOp aCompare, const Mpp16s aValue[3],
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                        MPPCompareOp aCompare, const Mpp16s aValue[3], DevPtrMpp16s aDst,
                                        size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                           MPPCompareOp aCompare, const Mpp16s aValue[3], DevPtrMpp16s aDst,
                                           size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aSrc2 fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, MPPCompareOp aCompare, const Mpp16s aValue[3],
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                         MPPCompareOp aCompare, const Mpp16s aValue[3], MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            MPPCompareOp aCompare, const Mpp16s aValue[3], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, const Mpp32f aTwist[3][3], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                             size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                             size_t aDst3Step, const Mpp32f aTwist[3][3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                           DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                           DevPtrMpp16s aDst3, size_t aDst3Step, const Mpp32f aTwist[3][3],
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_P3C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                             DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][3],
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix (inplace)
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp32f aTwist[3][3],
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422 (YCbCr/YCrCb/CbYCr).
    /// </summary>
    /// <param name="aDstLumaChroma">Destination image with Luma/Chroma interleaved</param>
    /// <param name="aTwist"></param>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciColorTwist3x3To422_16s_C3C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                  DevPtrMpp16s aDstLumaChroma, size_t aDstLumaChromaStep,
                                                  const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  bool aSwapLumaChroma, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To422_16s_C3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                  const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To422_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma1, size_t aDstChroma1Step,
                                                  DevPtrMpp16s aDstChroma2, size_t aDstChroma2Step,
                                                  const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To420_16s_C3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                  const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To420_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma1, size_t aDstChroma1Step,
                                                  DevPtrMpp16s aDstChroma2, size_t aDstChroma2Step,
                                                  const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To411_16s_C3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                  const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To411_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma1, size_t aDstChroma1Step,
                                                  DevPtrMpp16s aDstChroma2, size_t aDstChroma2Step,
                                                  const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422 (YCbCr/YCrCb/CbYCr).
    /// </summary>
    /// <param name="aDstLumaChroma">Destination image with Luma/Chroma interleaved</param>
    /// <param name="aTwist"></param>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciColorTwist3x3To422_16s_P3C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                  size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                  DevPtrMpp16s aDstLumaChroma, size_t aDstLumaChromaStep,
                                                  const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  bool aSwapLumaChroma, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To422_16s_P3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                  size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                  DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma,
                                                  size_t aDstChromaStep, const Mpp32f aTwist[3][3],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To422_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                size_t aDstChroma2Step, const Mpp32f aTwist[3][3],
                                                MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To420_16s_P3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                  size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                  DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma,
                                                  size_t aDstChromaStep, const Mpp32f aTwist[3][3],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To420_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                size_t aDstChroma2Step, const Mpp32f aTwist[3][3],
                                                MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To411_16s_P3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                  size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                  DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma,
                                                  size_t aDstChromaStep, const Mpp32f aTwist[3][3],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To411_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                size_t aDstChroma2Step, const Mpp32f aTwist[3][3],
                                                MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From422_16s_P2C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst, size_t aDstStep,
                                                    const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From422_16s_P3C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                    DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                    DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From422_16s_P2P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                    DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                    size_t aDst3Step, const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From422_16s_P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma1,
                                                  size_t aSrcChroma1Step, DevPtrMpp16s aSrcChroma2,
                                                  size_t aSrcChroma2Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                  DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                  size_t aDst3Step, const Mpp32f aTwist[3][3],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From420_16s_P2C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst, size_t aDstStep,
                                                    const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From420_16s_P3C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                    DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                    DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From420_16s_P2P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                    DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                    size_t aDst3Step, const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From420_16s_P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma1,
                                                  size_t aSrcChroma1Step, DevPtrMpp16s aSrcChroma2,
                                                  size_t aSrcChroma2Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                  DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                  size_t aDst3Step, const Mpp32f aTwist[3][3],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From411_16s_P2C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst, size_t aDstStep,
                                                    const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From411_16s_P3C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                    DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                    DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From411_16s_P2P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                    DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                    size_t aDst3Step, const Mpp32f aTwist[3][3],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From411_16s_P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma1,
                                                  size_t aSrcChroma1Step, DevPtrMpp16s aSrcChroma2,
                                                  size_t aSrcChroma2Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                  DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                  size_t aDst3Step, const Mpp32f aTwist[3][3],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, const Mpp32f aTwist[3][4], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                             size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                             size_t aDst3Step, const Mpp32f aTwist[3][4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                           DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                           DevPtrMpp16s aDst3, size_t aDst3Step, const Mpp32f aTwist[3][4],
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_P3C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                             DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][4],
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix (inplace)
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp32f aTwist[3][4],
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422 (YCbCr/YCrCb/CbYCr).
    /// </summary>
    /// <param name="aDstLumaChroma">Destination image with Luma/Chroma interleaved</param>
    /// <param name="aTwist"></param>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciColorTwist3x4To422_16s_C3C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                  DevPtrMpp16s aDstLumaChroma, size_t aDstLumaChromaStep,
                                                  const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  bool aSwapLumaChroma, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To422_16s_C3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                  const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To422_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma1, size_t aDstChroma1Step,
                                                  DevPtrMpp16s aDstChroma2, size_t aDstChroma2Step,
                                                  const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To420_16s_C3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                  const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To420_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma1, size_t aDstChroma1Step,
                                                  DevPtrMpp16s aDstChroma2, size_t aDstChroma2Step,
                                                  const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To411_16s_C3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                  const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To411_16s_C3P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                  size_t aDstLumaStep, DevPtrMpp16s aDstChroma1, size_t aDstChroma1Step,
                                                  DevPtrMpp16s aDstChroma2, size_t aDstChroma2Step,
                                                  const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422 (YCbCr/YCrCb/CbYCr).
    /// </summary>
    /// <param name="aDstLumaChroma">Destination image with Luma/Chroma interleaved</param>
    /// <param name="aTwist"></param>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciColorTwist3x4To422_16s_P3C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                  size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                  DevPtrMpp16s aDstLumaChroma, size_t aDstLumaChromaStep,
                                                  const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  bool aSwapLumaChroma, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To422_16s_P3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                  size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                  DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma,
                                                  size_t aDstChromaStep, const Mpp32f aTwist[3][4],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To422_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                size_t aDstChroma2Step, const Mpp32f aTwist[3][4],
                                                MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To420_16s_P3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                  size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                  DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma,
                                                  size_t aDstChromaStep, const Mpp32f aTwist[3][4],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To420_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                size_t aDstChroma2Step, const Mpp32f aTwist[3][4],
                                                MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To411_16s_P3P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                  size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                  DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma,
                                                  size_t aDstChromaStep, const Mpp32f aTwist[3][4],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To411_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                DevPtrMpp16s aDstLuma, size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                size_t aDstChroma2Step, const Mpp32f aTwist[3][4],
                                                MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From422_16s_P2C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst, size_t aDstStep,
                                                    const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From422_16s_P3C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                    DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                    DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From422_16s_P2P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                    DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                    size_t aDst3Step, const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From422_16s_P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma1,
                                                  size_t aSrcChroma1Step, DevPtrMpp16s aSrcChroma2,
                                                  size_t aSrcChroma2Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                  DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                  size_t aDst3Step, const Mpp32f aTwist[3][4],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From420_16s_P2C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst, size_t aDstStep,
                                                    const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From420_16s_P3C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                    DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                    DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From420_16s_P2P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                    DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                    size_t aDst3Step, const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From420_16s_P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma1,
                                                  size_t aSrcChroma1Step, DevPtrMpp16s aSrcChroma2,
                                                  size_t aSrcChroma2Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                  DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                  size_t aDst3Step, const Mpp32f aTwist[3][4],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From411_16s_P2C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst, size_t aDstStep,
                                                    const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From411_16s_P3C3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                    DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                    DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From411_16s_P2P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                    size_t aSrcChromaStep, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                    DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                    size_t aDst3Step, const Mpp32f aTwist[3][4],
                                                    MPPChromaSubsamplePos aChromaSubsamplePos,
                                                    MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From411_16s_P3(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma1,
                                                  size_t aSrcChroma1Step, DevPtrMpp16s aSrcChroma2,
                                                  size_t aSrcChroma2Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                                  DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                                  size_t aDst3Step, const Mpp32f aTwist[3][4],
                                                  MPPChromaSubsamplePos aChromaSubsamplePos,
                                                  MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                            DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                            DevPtrMpp16s aDst3, size_t aDst3Step, Mpp32f aNormFactor, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                               size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                               size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                               DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                               size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step,
                                               Mpp32f aNormFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                           DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                           DevPtrMpp16s aDst3, size_t aDst3Step, Mpp32f aNormFactor, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                              size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                              DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                              size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step,
                                              Mpp32f aNormFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                               MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a color gradient image to grayscale.
    /// </summary>
    MPPErrorCode mppciGradientColorToGray_16s_C3C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                                   size_t aDstStep, MPPNorm aNorm, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a color gradient image to grayscale.
    /// </summary>
    MPPErrorCode mppciGradientColorToGray_16s_P3C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                   size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                   DevPtrMpp16s aDst, size_t aDstStep, MPPNorm aNorm, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a multi-channel color image to a one channel gray scale image where each channel is weighted by the
    /// factor provided in aWeights.<para/> Common values to convert RGB to gray are nGray = 0.299 * R + 0.587 * G +
    /// 0.114 * B
    /// </summary>
    MPPErrorCode mppciColorToGray_16s_C3C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, const Mpp32f aWeights[3], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a multi-channel color image to a one channel gray scale image where each channel is weighted by the
    /// factor provided in aWeights.<para/> Common values to convert RGB to gray are nGray = 0.299 * R + 0.587 * G +
    /// 0.114 * B
    /// </summary>
    MPPErrorCode mppciColorToGray_16s_P3C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                           DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aWeights[3],
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// RGB Color to Grayscale Bayer Color Filter Array conversion.<para/>
    /// Depending on the chosen BayerGridPosition and pixel position, only either red, green or blue channel is stored
    /// in the destionation image.<para/> Image ROI must have even width and height.
    /// </summary>
    MPPErrorCode mppciRGBToCFA_16s_C3C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        MPPBayerGridPosition aBayerGrid, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion.<para/> aPalette is a pointer to number of color channels
    /// arrays of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        ConstDevPtrMpp16s aPalette[3], Mpp32s aBitSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion - inplace.<para/> aPalette is a pointer to number of color channels
    /// arrays of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aPalette[3],
                                         Mpp32s aBitSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 3 elements per pixel (red, green, blue).
    /// </summary>
    MPPErrorCode mppciLUTTrilinear_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                          ConstDevPtrMpp16s aLut3D, const Mpp16s aMinLevel[3],
                                          const Mpp16s aMaxLevel[3], const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 4 elements per pixel (red, green, blue), 4th channel is unused and is only
    /// for padding.
    /// </summary>
    MPPErrorCode mppciLUTTrilinearAC4_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                             size_t aDstStep, ConstDevPtrMpp16s aLut3D, const Mpp16s aMinLevel[3],
                                             const Mpp16s aMaxLevel[3], const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation - inline.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 3 elements per pixel (red, green, blue).
    /// </summary>
    MPPErrorCode mppciLUTTrilinear_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aLut3D,
                                           const Mpp16s aMinLevel[3], const Mpp16s aMaxLevel[3],
                                           const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation - inline.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 4 elements per pixel (red, green, blue), 4th channel is unused and is only
    /// for padding.
    /// </summary>
    MPPErrorCode mppciLUTTrilinearAC4_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aLut3D,
                                              const Mpp16s aMinLevel[3], const Mpp16s aMaxLevel[3],
                                              const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrc1 source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the destination image aDst.
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_C3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, const Mpp16s aColorKey[3], DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrcDst source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the same source image (inplace operation).
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_C3I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, const Mpp16s aColorKey[3], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts from planar P2 422 sampling to packed C2 422 sampling.
    /// </summary>
    /// <param name="aSwapLumaChroma">Set to false if output should be in format YCbCr, true for CbYCr.</param>
    MPPErrorCode mppciConvertSampling422_16s_P2C2(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma,
                                                  size_t aSrcChromaStep, DevPtrMpp16s aDstLumaChroma,
                                                  size_t aDstLumaChromaStep, bool aSwapLumaChroma, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts from planar P3 422 sampling to packed C2 422 sampling.
    /// </summary>
    /// <param name="aSwapLumaChroma">Set to false if output should be in format YCbCr, true for CbYCr.</param>
    MPPErrorCode mppciConvertSampling422_16s_P3C2(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep, DevPtrMpp16s aSrcChroma1,
                                                  size_t aSrcChroma1Step, DevPtrMpp16s aSrcChroma2,
                                                  size_t aSrcChroma2Step, DevPtrMpp16s aDstLumaChroma,
                                                  size_t aDstLumaChromaStep, bool aSwapLumaChroma, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with mask. Pixels with mask == 0 remain untouched in destination image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                   ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy packed image pixels to planar images.
    /// </summary>
    MPPErrorCode mppciCopy_16s_C4P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstChannel1,
                                    size_t aDstChannel1Step, DevPtrMpp16s aDstChannel2, size_t aDstChannel2Step,
                                    DevPtrMpp16s aDstChannel3, size_t aDstChannel3Step, DevPtrMpp16s aDstChannel4,
                                    size_t aDstChannel4Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy planar image pixels to packed pixel image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_P4C4(DevPtrMpp16s aSrcChannel1, size_t aSrcChannel1Step, DevPtrMpp16s aSrcChannel2,
                                    size_t aSrcChannel2Step, DevPtrMpp16s aSrcChannel3, size_t aSrcChannel3Step,
                                    DevPtrMpp16s aSrcChannel4, size_t aSrcChannel4Step, DevPtrMpp16s aDst,
                                    size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aBorder">Border control paramter</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    MPPErrorCode mppciCopyBorder_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        const Mpp32s aLowerBorderSize[2], MPPBorderType aBorder, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    /// <param name="aBorder">Border control paramter</param>
    MPPErrorCode mppciCopyBorder_16s_C4Cb(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                          const Mpp32s aLowerBorderSize[2], const Mpp16s aConstant[4],
                                          MPPBorderType aBorder, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy subpix.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aDelta">Fractional part of source image coordinate</param>
    /// <param name="aInterpolation">Interpolation mode to use</param>
    MPPErrorCode mppciCopySubpix_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        const Mpp32f aDelta[2], MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C4IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                    ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C4IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set channel aChannel of all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_C4CI(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aChannel,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set channel aChannel of all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_C4CI(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       Mpp32s aChannel, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Swap channels (inplace)<para/>
    /// aDstChannels describes how channel values are permutated. The n-th entry
    /// of the array contains the number of the channel that is stored in the n-th channel of
    /// the output image. <para/>
    /// E.g. Given an RGB image, aDstChannels = [2,1,0] converts aSrcDst to BGR channel order.
    /// </summary>
    MPPErrorCode mppciSwapChannel_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp32s aDstChannels[4],
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Transpose image.
    /// </summary>
    MPPErrorCode mppciTranspose_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                       MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInv_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInv_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                    MPPRoundingMode aRoundingMode, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                     DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                     MPPRoundingMode aRoundingMode, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                        DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                        MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                      Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInv_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_C4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                     size_t aMaskStep, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                      DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                      MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                       ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                       MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInv_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                          ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                          MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_C4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                             MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_C4I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                           size_t aSrcDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                           size_t aSrcDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_C4I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C4I(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                             size_t aSrcDstStep, Mpp32f aAlpha, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_C4IM(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                              size_t aSrcDstStep, Mpp32f aAlpha, ConstDevPtrMpp8u aMask,
                                              size_t aMaskStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = abs(aSrc1)
    /// </summary>
    MPPErrorCode mppciAbs_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = abs(aSrcDst)
    /// </summary>
    MPPErrorCode mppciAbs_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4], DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = ~aSrc1 (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = ~aSrcDst (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = exp(aSrc1) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = exp(aSrcDst) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = log(aSrc1) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = log(aSrcDst) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4], DevPtrMpp16s aDst,
                                 size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4], MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                     size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc1 (aSrc1^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst * aSrcDst (aSrcDst^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = Sqrt(aSrc1) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = Sqrt(aSrcDst) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4], DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with alpha from fourth color channel.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremul_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with alpha from fourth color channel.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremul_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aAlpha, DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aAlpha, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using alpha opacity values contained in each image. Last color channel is alpha channel, 1
    /// channel images are treated as alpha channel only.
    /// </summary>
    MPPErrorCode mppciAlphaComp_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MPPAlphaOp aAlphaOp,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using constant alpha values.
    /// </summary>
    MPPErrorCode mppciAlphaCompC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp16s aAlpha1,
                                        Mpp16s aAlpha2, MPPAlphaOp aAlphaOp, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst.real = aSrc1, aDst.imag = 0 (converts real valued image to complex with imaginary part = 0)
    /// </summary>
    MPPErrorCode mppciMakeComplex_16s16sc_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16sc aDst,
                                             size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst.real = aSrc1, aDst.imag = aSrcImag (converts two real valued images to one complex image)
    /// </summary>
    MPPErrorCode mppciMakeComplexImag_16s16sc_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrcImag,
                                                 size_t aSrcImagStep, DevPtrMpp16sc aDst, size_t aDstStep,
                                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            MPPFixedFilter aFilter, MPPMaskSize aMaskSize, const Mpp16s aConstant[4],
                                            MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, MPPFixedFilter aFilter,
                                          MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                               MPPFixedFilter aFilter, MPPMaskSize aMaskSize, const Mpp16s aConstant[4],
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MPPFixedFilter aFilter, MPPMaskSize aMaskSize, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                                const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                             const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                           MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                   MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                   Mpp32s aFilterCenter, const Mpp16s aConstant[4],
                                                   MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                 MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                 Mpp32s aFilterCenter, MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                          const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                                Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                                const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                              Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                             MppiFilterArea aFilterArea, const Mpp16s aConstant[4],
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Median filter (only filter sizes 3x3, 5x5 and 7x7 are implemented).
    /// </summary>
    MPPErrorCode mppciMedianFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MppiFilterArea aFilterArea, const Mpp32f aNoise[4],
                                             const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, const Mpp32f aNoise[4], MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                           MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                           MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                           const Mpp32f aDelta[4], const Mpp16s aValGT[4],
                                                           const Mpp16s aValLE[4], const Mpp16s aConstant[4],
                                                           MPPBorderType aBorder, MppiRect aSrcROI,
                                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                         MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                         MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                         const Mpp32f aDelta[4], const Mpp16s aValGT[4],
                                                         const Mpp16s aValLE[4], MPPBorderType aBorder,
                                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                       MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea,
                                          const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    /// <param name="aNorm">Norm to use when computing the pixel weight for multi-channel images.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                     MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                     MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                     ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                     MPPNorm aNorm, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    /// <param name="aNorm">Norm to use when computing the pixel weight for multi-channel images.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                   ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                   MPPNorm aNorm, MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                       MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
                                                       DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag,
                                                       size_t aDstMagStep, DevPtrMpp32f aDstAngle, size_t aDstAngleStep,
                                                       DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep,
                                                       MppiSize aDstSize, MPPNorm aNorm, MPPMaskSize aMaskSize,
                                                       const Mpp16s aConstant[4], MPPBorderType aBorder,
                                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_C4R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_C4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_C4R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_C4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_C4R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              Mpp32f aWeight, Mpp32f aThreshold, const Mpp16s aConstant[4],
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                            Mpp32f aWeight, Mpp32f aThreshold, MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                           const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                         MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_P4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                           ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                           ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                           ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                           DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                           MppiSize aDstSize, const Mpp64f aAffine[2][3],
                                           MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
                                           MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_P4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                         ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                         ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                         ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                         DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                         MppiSize aDstSize, const Mpp64f aAffine[2][3],
                                         MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                               const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to
    /// use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_P4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step,
        MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
        DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step, MppiSize aDstSize,
        const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to
    /// use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_P4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                             ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                             ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                             ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                             DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                             MppiSize aDstSize, const Mpp64f aAffine[2][3],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                                const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_P4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step,
        MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
        DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step, MppiSize aDstSize,
        const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_P4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                              ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                              ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                              ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2,
                                              size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step,
                                              DevPtrMpp16s aDst4, size_t aDst4Step, MppiSize aDstSize,
                                              const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                    MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                    MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                    MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
                                                    MPPBorderType aBorder, MppiRect aSrcROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                  MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                  MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                                  MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_P4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step,
        MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
        DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step, MppiSize aDstSize,
        const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_P4R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step,
        MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
        DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step, MppiSize aDstSize,
        const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                       const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                       const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                     const Mpp64f aShift[2], MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_P4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                       size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                       ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                       DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                       MppiSize aDstSize, Mpp64f aAngleInDeg, const Mpp64f aShift[2],
                                       MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
                                       MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_P4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                     size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                     ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                     DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                     MppiSize aDstSize, Mpp64f aAngleInDeg, const Mpp64f aShift[2],
                                     MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize<para/>
    /// Simplified API to rescale from source image ROI to destination image ROI.<para/>
    /// NOTE: the result is NOT the same as in NPP using the same function. The shift applied in NPP for the same
    /// function don't make much sense to me, in MPP Resize matches the input extent [-0.5 .. srcWidth-0.5[ to the
    /// output [-0.5 .. dstWidth-0.5[. Whereas NPP applies different strategies for up-and downscaling. In order to get
    /// the same results as in NPP, use an user defined scaling factor of <para/> Vec2d scaleFactor =
    /// Vec2d(dstImg.SizeRoi()) / Vec2d(srcImg.SizeRoi());<para/> and a shift given by ResizeGetNPPShift().
    /// </summary>
    MPPErrorCode mppciResize_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize<para/>
    /// Simplified API to rescale from source image ROI to destination image ROI.<para/>
    /// NOTE: the result is NOT the same as in NPP using the same function. The shift applied in NPP for the same
    /// function don't make much sense to me, in MPP Resize matches the input extent [-0.5 .. srcWidth-0.5[ to the
    /// output [-0.5 .. dstWidth-0.5[. Whereas NPP applies different strategies for up-and downscaling. In order to get
    /// the same results as in NPP, use an user defined scaling factor of <para/> Vec2d scaleFactor =
    /// Vec2d(dstImg.SizeRoi()) / Vec2d(srcImg.SizeRoi());<para/> and a shift given by ResizeGetNPPShift().
    /// </summary>
    MPPErrorCode mppciResize_16s_P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                    ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst1, size_t aDst1Step,
                                    DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3, size_t aDst3Step,
                                    DevPtrMpp16s aDst4, size_t aDst4Step, MPPInterpolationMode aInterpolation,
                                    MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aScale[2], const Mpp64f aShift[2],
                                               MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             const Mpp64f aScale[2], const Mpp64f aShift[2],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_P4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step, ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step,
        MppiSize aSrcFullSize, DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
        DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step, MppiSize aDstSize,
        const Mpp64f aScale[2], const Mpp64f aShift[2], MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_P4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                             ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                             ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                             ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                             DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                             MppiSize aDstSize, const Mpp64f aScale[2], const Mpp64f aShift[2],
                                             MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                             MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis
    /// </summary>
    MPPErrorCode mppciMirror_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    MPPMirrorAxis aAxis, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis (inplace operation)
    /// </summary>
    MPPErrorCode mppciMirror_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MPPMirrorAxis aAxis, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                        MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                      MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                      ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                      ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                      MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                    ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                    ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                    MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_P4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                        ConstDevPtrMpp16s aSrc2BasePtr, size_t aSrc2Step,
                                        ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                        ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                        DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                        MppiSize aDstSize, ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                        MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
                                        MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_P4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                      size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                      ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                      DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                      MppiSize aDstSize, ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                      MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_P4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                      size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                      ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                      DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                      MppiSize aDstSize, ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                      ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                      MPPInterpolationMode aInterpolation, const Mpp16s aConstant[4],
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_P4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2BasePtr,
                                    size_t aSrc2Step, ConstDevPtrMpp16s aSrc3BasePtr, size_t aSrc3Step,
                                    ConstDevPtrMpp16s aSrc4BasePtr, size_t aSrc4Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aDst1, size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                    DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                    MppiSize aDstSize, ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                    ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                    MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, MppiFilterArea aFilterArea,
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                            const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                          MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea,
                                            const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                             const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea,
                                             const Mpp16s aConstant[4], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                     MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                   DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                   DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                   MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                      MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                      MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                    MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                         MppiFilterArea aFilterArea, const Mpp16s aConstant[4], MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_C4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                                   MppiFilterArea aFilterArea, const Mpp16s aConstant[4],
                                                   MPPBorderType aBorder, MppiRect aSrcROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_C4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                 MppiSize aDstSize, ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                                 MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/> For multi-channel images, the result is computed for each channel seperatly in
    /// aDst, or for all channels in aDstScalar. <para/> If the image is in complex format, the absolute value is used
    /// for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProduct.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProductMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j)) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j)) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSE.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSEMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                    size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer,
                                    size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/> For multi-channel images, the result is computed for each channel
    /// seperatly in aDst, or for all channels in aDstScalar. <para/> If the image is in complex format, the absolute
    /// value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm of difference of pixels between two images.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm of difference of pixels between two images.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm of difference of pixels between two images.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative infinity norm of difference of pixels between two images.<para/>
    /// The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) / NormInf(Src2)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative infinity norm of difference of pixels between two images where only pixels with mask != 0
    /// are used.<para/> The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) /
    /// NormInf(Src2)<para/> For multi-channel images, the result is computed for each channel seperatly in aDst, or for
    /// all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L1 norm of difference of pixels between two images.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                          DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L1 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                           size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L2 norm of difference of pixels between two images.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                          DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L2 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                           size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for PSNR.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciPSNRBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the PSNR of two images. <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aValueRange">The maximum possible pixel value, eg. 255 for 8 bit unsigned int images,
    /// 4095 for 12-bit unsigned images, etc.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciPSNR_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar, Mpp64f aValueRange,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                         DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                    DevPtrMpp64s aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                    DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                     DevPtrMpp64s aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                     DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Mean.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                     DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStd.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStdMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aMean">Per-channel mean value, can be nullptr if aStd is also nullptr</param>
    /// <param name="aStd">Per-channel standard deviation value, can be nullptr if aMean is also nullptr</param>
    /// <param name="aMeanScalar">Mean value for all channels, can be nullptr if aStdScalar is also nullptr</param>
    /// <param name="aStdScalar">Standard deviation for all channels, can be nullptr if aMeanScalar is also
    /// nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                     DevPtrMpp64f aMeanScalar, DevPtrMpp64f aStdScalar, DevPtrMpp8u aBuffer,
                                     size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values where only pixels with mask != 0 are used.<para/>For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aMean">Per-channel mean value, can be nullptr if aStd is also nullptr</param>
    /// <param name="aStd">Per-channel standard deviation value, can be nullptr if aMean is also nullptr</param>
    /// <param name="aMeanScalar">Mean value for all channels, can be nullptr if aStdScalar is also nullptr</param>
    /// <param name="aStdScalar">Standard deviation for all channels, can be nullptr if aMeanScalar is also
    /// nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                      DevPtrMpp64f aMeanScalar, DevPtrMpp64f aStdScalar, ConstDevPtrMpp8u aMask,
                                      size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRangeMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aLowerLimit[4],
                                             const Mpp16s aUpperLimit[4], DevPtrMpp64u aDst, DevPtrMpp64u aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range where only pixels with mask != 0 are used.<para/>For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aLowerLimit[4],
                                              const Mpp16s aUpperLimit[4], DevPtrMpp64u aDst, DevPtrMpp64u aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the image quality index of two images. This implementation is identical to the one in NPP computing a
    /// global index without a sliding window.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndex_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndexWindow.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexWindowBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the QualityIndex of two images. This function is implemented using a sliding window approach as is done
    /// in the original paper / code with a window size of 11x11 pixels.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndexWindow_16s32f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                   size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer,
                                                   size_t aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSSIMBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically this is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSSIM_16s32f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSSSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSSSIMBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Multi-Scale-SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically aSrc1 is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSSSIM_16s32f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Min.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value.
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                 DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value where only pixels with mask != 0 are used.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                  ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Max.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value.
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                 DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value where only pixels with mask != 0 are used.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                  ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMax.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value.<para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax, or for all
    /// channels in aDstMinScalar/aDstMaxScalar.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstMax is also nullptr</param>
    /// <param name="aDstMax">Per-channel maximum value, can be nullptr if aDstMin is also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr if aDstMaxScalar also nullptr</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels, can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                    DevPtrMpp16s aDstMax, DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                    DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value where only pixels with mask != 0 are used.<para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax, or for all
    /// channels in aDstMinScalar/aDstMaxScalar.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstMax is also nullptr</param>
    /// <param name="aDstMax">Per-channel maximum value, can be nullptr if aDstMin is also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr if aDstMaxScalar also nullptr</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels, can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                     DevPtrMpp16s aDstMax, DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is computed for each
    /// channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the minimum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                      DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMinScalar,
                                      DevPtrMpp32s aDstScalarIdx, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels
    /// in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the minimum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                       DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMinScalar,
                                       DevPtrMpp32s aDstScalarIdx, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is computed for each
    /// channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel maximum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Maximum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the maximum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                      DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMaxScalar,
                                      DevPtrMpp32s aDstScalarIdx, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels
    /// in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel maximum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Maximum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the maximum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                       DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMaxScalar,
                                       DevPtrMpp32s aDstScalarIdx, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_C4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices. For multiple occurences of the same value the index
    /// with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is
    /// computed for each channel seperatly in aDstMin/aDstMax/aDstIdx, or for all channels in
    /// aDstMinScalar/aDstMaxScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Minimum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMax and aDstIdx are also nullptr.</param>
    /// <param name="aDstMax">Maximum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstIdx are also nullptr.</param>
    /// <param name="aDstIdx">Pixel index for min and max value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstMax are also nullptr.</param>
    /// <param name="aDstMinScalar">Minimum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMaxScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstScalarIdx">Pixel index for min and max value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstMaxScalar are also nullptr.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                         DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx,
                                         DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                         DevPtrMppiIndexMinMaxChannel aDstScalarIdx, DevPtrMpp8u aBuffer,
                                         size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices where only pixels with mask != 0 are used. For multiple
    /// occurences of the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax/aDstIdx, or for all
    /// channels in aDstMinScalar/aDstMaxScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Minimum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMax and aDstIdx are also nullptr.</param>
    /// <param name="aDstMax">Maximum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstIdx are also nullptr.</param>
    /// <param name="aDstIdx">Pixel index for min and max value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstMax are also nullptr.</param>
    /// <param name="aDstMinScalar">Minimum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMaxScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstScalarIdx">Pixel index for min and max value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstMaxScalar are also nullptr.</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_C4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                          DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx,
                                          DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                          DevPtrMppiIndexMinMaxChannel aDstScalarIdx, ConstDevPtrMpp8u aMask,
                                          size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s32s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s32f_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s64s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Integral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciIntegralBufferSize_16s64f_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32s32s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32s64s_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s32f64f_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SqrIntegral.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSqrIntegralBufferSize_16s64f64f_C4(size_t *aBufferSize, MppiSize aSizeROI,
                                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s32s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst, size_t aDstStep,
                                         const Mpp32s aVal[4], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s32f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aDst, size_t aDstStep,
                                         const Mpp32f aVal[4], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s64s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst, size_t aDstStep,
                                         const Mpp64s aVal[4], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    /// <returns></returns>
    MPPErrorCode mppciIntegral_16s64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst, size_t aDstStep,
                                         const Mpp64f aVal[4], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROISrc, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32s32s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst,
                                               size_t aDstStep, DevPtrMpp32s aSqr, size_t aSqrStep,
                                               const Mpp32s aVal[4], const Mpp32s aValSqr[4], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32s64s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aDst,
                                               size_t aDstStep, DevPtrMpp64s aSqr, size_t aSqrStep,
                                               const Mpp32s aVal[4], const Mpp64s aValSqr[4], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s32f64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aDst,
                                               size_t aDstStep, DevPtrMpp64f aSqr, size_t aSqrStep,
                                               const Mpp32f aVal[4], const Mpp64f aValSqr[4], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the integral image and the squared integral image.
    /// </summary>
    /// <param name="aDst">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aSqr">ROI of destination image must be 1 pixel larger in width and height than source ROI.</param>
    /// <param name="aVal">The value to add to aDst image pixels.</param>
    /// <param name="aValSqr">The value to add to aSqr image pixels</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSqrIntegral_16s64f64f_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                               size_t aDstStep, DevPtrMpp64f aSqr, size_t aSqrStep,
                                               const Mpp64f aVal[4], const Mpp64f aValSqr[4], DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROISrc,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = min(aSrc1, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = min(aSrcDst, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = max(aSrc1, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = max(aSrcDst, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramEven.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramEvenBufferSize_16s_C4(size_t *aBufferSize, const Mpp32s aNumLevels[4], MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The aLowerLevel (inclusive) and aUpperLevel (exclusive) define the boundaries of the range,
    /// which are evenly segmented into aHist.Size() bins.
    /// </summary>
    /// <param name="aHist">host array of device memory pointers to the computed histograms
    /// (one for each active channel). The size of aHist[channel] gives the number of bins used.</param>
    /// <param name="aLowerLevel">lower level (inclusive, per channel)</param>
    /// <param name="aUpperLevel">upper level (exclusive, per channel)</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramEven_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist[4],
                                           const Mpp32s aLowerLevel[4], const Mpp32s aUpperLevel[4],
                                           Mpp32s aNumLevels[4], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramRangeBufferSize_16s_C4(size_t *aBufferSize, const Mpp32s aNumLevels[4],
                                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the histogram of an image within specified ranges.
    /// </summary>
    /// <param name="aHist">host array of device memory pointers to the computed histograms
    /// (one for each active channel). The size of aHist[channel] gives the number of bins used.</param>
    /// <param name="aLevels">host array of device memory pointers to the array
    /// with the range defintions, one array per channel. The levels array must be one element
    /// larger than the histogram array, as number of levels = number of bins + 1.</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramRange_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist[4],
                                            ConstDevPtrMpp32s aLevels[4], Mpp32s aNumLevels[4], DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCircularRadialProfile_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                   DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                   DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                   const Mpp32f aCenter[2], MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aRadiusRatio">Ratio of orientation axis to orthogonal axis. (i.e. 1.5 means stretched 1.5x)</param>
    /// <param name="aAngleInDeg">Orientation of the ellipse's orthogonal axis, clockwise in degrees with 0.0 being
    /// vertical.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciEllipticalRadialProfile_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                     DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                     DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                     const Mpp32f aCenter[2], Mpp32f aRadiusRatio, Mpp32f aAngleInDeg,
                                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_C4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_C4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                          MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_C4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                             MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                        MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                           MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThreshold_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[4],
                                       MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                           MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[4],
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[4],
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThreshold_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[4],
                                        MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                            MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[4],
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[4],
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[4],
                                          const Mpp16s aValue[4], MPPCompareOp aCompare, DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[4],
                                            const Mpp16s aValue[4], DevPtrMpp16s aDst, size_t aDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[4],
                                            const Mpp16s aValue[4], DevPtrMpp16s aDst, size_t aDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[4],
                                           const Mpp16s aValue[4], MPPCompareOp aCompare, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[4],
                                             const Mpp16s aValue[4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[4],
                                             const Mpp16s aValue[4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThresholdLT[4],
                                           const Mpp16s aValueLT[4], const Mpp16s aThresholdGT[4],
                                           const Mpp16s aValueGT[4], DevPtrMpp16s aDst, size_t aDstStep,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThresholdLT[4],
                                            const Mpp16s aValueLT[4], const Mpp16s aThresholdGT[4],
                                            const Mpp16s aValueGT[4], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aSrc2 fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, MPPCompareOp aCompare, const Mpp16s aValue[4],
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[4],
                                        MPPCompareOp aCompare, const Mpp16s aValue[4], DevPtrMpp16s aDst,
                                        size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                           MPPCompareOp aCompare, const Mpp16s aValue[4], DevPtrMpp16s aDst,
                                           size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aSrc2 fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, MPPCompareOp aCompare, const Mpp16s aValue[4],
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[4],
                                         MPPCompareOp aCompare, const Mpp16s aValue[4], MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                            MPPCompareOp aCompare, const Mpp16s aValue[4], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_C4P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                             size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                             size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                             const Mpp32f aTwist[3][3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix. Alpha channel in destination image is set to aAlpha.
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_P3C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                             DevPtrMpp16s aDst, size_t aDstStep, Mpp16s aAlpha,
                                             const Mpp32f aTwist[3][3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_P4C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                             ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst,
                                             size_t aDstStep, const Mpp32f aTwist[3][3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_C4P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                             size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                             size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                             const Mpp32f aTwist[3][4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix. Alpha channel in destination image is set to aAlpha.
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_P3C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                             DevPtrMpp16s aDst, size_t aDstStep, Mpp16s aAlpha,
                                             const Mpp32f aTwist[3][4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_P4C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                             ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst,
                                             size_t aDstStep, const Mpp32f aTwist[3][4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist4x4_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, const Mpp32f aTwist[4][4], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist4x4_16s_C4P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                             size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                             size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                             const Mpp32f aTwist[4][4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist4x4_16s_P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                           ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst1,
                                           size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                           size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                           const Mpp32f aTwist[4][4], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist4x4_16s_P4C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                             ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst,
                                             size_t aDstStep, const Mpp32f aTwist[4][4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix (inplace)
    /// </summary>
    MPPErrorCode mppciColorTwist4x4_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp32f aTwist[4][4],
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix and an additional constant vector addition
    /// </summary>
    MPPErrorCode mppciColorTwist4x4C_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, const Mpp32f aTwist[4][4], const Mpp32f aConstant[4],
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix and an additional constant vector addition
    /// </summary>
    MPPErrorCode mppciColorTwist4x4C_16s_C4P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                              size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                              DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4,
                                              size_t aDst4Step, const Mpp32f aTwist[4][4], const Mpp32f aConstant[4],
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix and an additional constant vector addition
    /// </summary>
    MPPErrorCode mppciColorTwist4x4C_16s_P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                            ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst1,
                                            size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                            size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step,
                                            const Mpp32f aTwist[4][4], const Mpp32f aConstant[4], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix and an additional constant vector addition
    /// </summary>
    MPPErrorCode mppciColorTwist4x4C_16s_P4C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                              ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst,
                                              size_t aDstStep, const Mpp32f aTwist[4][4], const Mpp32f aConstant[4],
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 4x4 matrix (inplace) and an additional constant vector addition
    /// </summary>
    MPPErrorCode mppciColorTwist4x4C_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp32f aTwist[4][4],
                                             const Mpp32f aConstant[4], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                            ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst1,
                                            size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                            size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step, Mpp32f aNormFactor,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                               size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                               size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                               ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst1,
                                               size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                               DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4,
                                               size_t aDst4Step, Mpp32f aNormFactor, MppiSize aSizeROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                           ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst1,
                                           size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step, DevPtrMpp16s aDst3,
                                           size_t aDst3Step, DevPtrMpp16s aDst4, size_t aDst4Step, Mpp32f aNormFactor,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                              size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_P4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                              ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst1,
                                              size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                              DevPtrMpp16s aDst3, size_t aDst3Step, DevPtrMpp16s aDst4,
                                              size_t aDst4Step, Mpp32f aNormFactor, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                               MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a color gradient image to grayscale.
    /// </summary>
    MPPErrorCode mppciGradientColorToGray_16s_C4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                                   size_t aDstStep, MPPNorm aNorm, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a color gradient image to grayscale.
    /// </summary>
    MPPErrorCode mppciGradientColorToGray_16s_P4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                   size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                                   ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst,
                                                   size_t aDstStep, MPPNorm aNorm, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a multi-channel color image to a one channel gray scale image where each channel is weighted by the
    /// factor provided in aWeights.<para/> Common values to convert RGB to gray are nGray = 0.299 * R + 0.587 * G +
    /// 0.114 * B
    /// </summary>
    MPPErrorCode mppciColorToGray_16s_C4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, const Mpp32f aWeights[4], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a multi-channel color image to a one channel gray scale image where each channel is weighted by the
    /// factor provided in aWeights.<para/> Common values to convert RGB to gray are nGray = 0.299 * R + 0.587 * G +
    /// 0.114 * B
    /// </summary>
    MPPErrorCode mppciColorToGray_16s_P4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                           ConstDevPtrMpp16s aSrc4, size_t aSrc4Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, const Mpp32f aWeights[4], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion.<para/> aPalette is a pointer to number of color channels
    /// arrays of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                        ConstDevPtrMpp16s aPalette[4], Mpp32s aBitSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion - inplace.<para/> aPalette is a pointer to number of color channels
    /// arrays of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aPalette[4],
                                         Mpp32s aBitSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 3 elements per pixel (red, green, blue).
    /// </summary>
    MPPErrorCode mppciLUTTrilinear_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                          ConstDevPtrMpp16s aLut3D, const Mpp16s aMinLevel[3],
                                          const Mpp16s aMaxLevel[3], const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 4 elements per pixel (red, green, blue), 4th channel is unused and is only
    /// for padding.
    /// </summary>
    MPPErrorCode mppciLUTTrilinearAC4_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                             size_t aDstStep, ConstDevPtrMpp16s aLut3D, const Mpp16s aMinLevel[3],
                                             const Mpp16s aMaxLevel[3], const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation - inline.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 3 elements per pixel (red, green, blue).
    /// </summary>
    MPPErrorCode mppciLUTTrilinear_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aLut3D,
                                           const Mpp16s aMinLevel[3], const Mpp16s aMaxLevel[3],
                                           const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation - inline.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 4 elements per pixel (red, green, blue), 4th channel is unused and is only
    /// for padding.
    /// </summary>
    MPPErrorCode mppciLUTTrilinearAC4_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aLut3D,
                                              const Mpp16s aMinLevel[3], const Mpp16s aMaxLevel[3],
                                              const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrc1 source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the destination image aDst.
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_C4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, const Mpp16s aColorKey[4], DevPtrMpp16s aDst,
                                          size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrcDst source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the same source image (inplace operation).
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_C4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, const Mpp16s aColorKey[4], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with mask. Pixels with mask == 0 remain untouched in destination image.
    /// </summary>
    MPPErrorCode mppciCopy_16s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                    ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aBorder">Border control paramter</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    MPPErrorCode mppciCopyBorder_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                         const Mpp32s aLowerBorderSize[2], MPPBorderType aBorder, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy image with border.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aLowerBorderSize">Size of the border to add on the lower coordinate side
    /// (usually left and top side of the image)</param>
    /// <param name="aConstant">Constant value needed in case BorderType::Constant</param>
    /// <param name="aBorder">Border control paramter</param>
    MPPErrorCode mppciCopyBorder_16s_AC4Cb(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, const Mpp32s aLowerBorderSize[2], const Mpp16s aConstant[3],
                                           MPPBorderType aBorder, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Copy subpix.
    /// </summary>
    /// <param name="aDst">Destination image</param>
    /// <param name="aDelta">Fractional part of source image coordinate</param>
    /// <param name="aInterpolation">Interpolation mode to use</param>
    MPPErrorCode mppciCopySubpix_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                         const Mpp32f aDelta[2], MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3], MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_AC4IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                     ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set all pixels with aMask != 0 to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_AC4IM(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                        ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set channel aChannel of all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetC_16s_AC4CI(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aConst, Mpp32s aChannel,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Set channel aChannel of all pixels in current ROI to aConst
    /// </summary>
    MPPErrorCode mppciSetDevC_16s_AC4CI(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                        Mpp32s aChannel, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                      DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAdd_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                       Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                      size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                       DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                          DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                          Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAdd_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                        ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciAddDevC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 + aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                      DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSub_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                       Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInv_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                          Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                      size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                       DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 - aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                          DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                          Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSub_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                        ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst -= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciSubDevC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInv_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                          Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst - aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciSubInvDevC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                      DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMul_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                       Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                      size_t aMaskStep, Mpp32s aScaleFactor, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                       DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                          DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                          Mpp32s aScaleFactor, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMul_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                        ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst *= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciMulDevC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                     MPPRoundingMode aRoundingMode, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                      DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                      MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_AC4Sfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                         DevPtrMpp16s aDst, size_t aDstStep, Mpp32s aScaleFactor,
                                         MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDiv_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                       Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                          Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInv_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                          Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_AC4ISfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask,
                                      size_t aMaskStep, Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                       DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 / aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels
    /// where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_AC4MSfs(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                          DevPtrMpp16s aDst, size_t aDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                          Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aSrc2, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDiv_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                       MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                        ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                        MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst /= aConst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all pixels where
    /// aMask != 0
    /// </summary>
    MPPErrorCode mppciDivDevC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                           MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc2 / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInv_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                          Mpp32s aScaleFactor, MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                           ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                           MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aConst / aSrcDst, with floating point scaling factor with scale factor = 2^-aScaleFactor, for all
    /// pixels where aMask != 0
    /// </summary>
    MPPErrorCode mppciDivInvDevC_16s_AC4IMSfs(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, Mpp32s aScaleFactor,
                                              MPPRoundingMode aRoundingMode, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_AC4I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                            size_t aSrcDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1^2
    /// </summary>
    MPPErrorCode mppciAddSquare_16s32f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                            size_t aSrcDstStep, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_AC4I(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst += aSrc1 * aSrc2
    /// </summary>
    MPPErrorCode mppciAddProduct_16s32f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp32f aSrcDst, size_t aSrcDstStep,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * alpha + aSrc2 * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp32f aDst, size_t aDstStep, Mpp32f aAlpha,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_AC4I(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                              size_t aSrcDstStep, Mpp32f aAlpha, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrc1 * alpha + aSrcDst * (1 - alpha)
    /// </summary>
    MPPErrorCode mppciAddWeighted_16s32f_AC4IM(DevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32f aSrcDst,
                                               size_t aSrcDstStep, Mpp32f aAlpha, ConstDevPtrMpp8u aMask,
                                               size_t aMaskStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = abs(aSrc1)
    /// </summary>
    MPPErrorCode mppciAbs_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = abs(aSrcDst)
    /// </summary>
    MPPErrorCode mppciAbs_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3], DevPtrMpp16s aDst,
                                   size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aSrc2 (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAnd_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3], MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst & aConst (bitwise AND)
    /// </summary>
    MPPErrorCode mppciAndDevC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = ~aSrc1 (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = ~aSrcDst (bitwise NOT)
    /// </summary>
    MPPErrorCode mppciNot_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = exp(aSrc1) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = exp(aSrcDst) (exponential function)
    /// </summary>
    MPPErrorCode mppciExp_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = log(aSrc1) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = log(aSrcDst) (natural logarithm)
    /// </summary>
    MPPErrorCode mppciLn_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                      size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst << aConst (left bitshift)
    /// </summary>
    MPPErrorCode mppciLShiftC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                 DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3], DevPtrMpp16s aDst,
                                  size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aSrc2 (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOr_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3], MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst | aConst (bitwise Or)
    /// </summary>
    MPPErrorCode mppciOrDevC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp32u aConst, DevPtrMpp16s aDst,
                                      size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst >> aConst (right bitshift)
    /// </summary>
    MPPErrorCode mppciRShiftC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32u aConst, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 * aSrc1 (aSrc1^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                  MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst * aSrcDst (aSrcDst^2)
    /// </summary>
    MPPErrorCode mppciSqr_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = Sqrt(aSrc1) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = Sqrt(aSrcDst) (square root function)
    /// </summary>
    MPPErrorCode mppciSqrt_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                  DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3], DevPtrMpp16s aDst,
                                   size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = aSrc1 ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aSrc2 (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXor_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2, size_t aSrc2Step,
                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3], MppiSize aSizeROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = aSrcDst ^ aConst (bitwise Xor)
    /// </summary>
    MPPErrorCode mppciXorDevC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value.
    /// Note: AlphaPremul does not exactly match the results from NPP for integer image types. NPP seems to scale the
    /// integer value by T::max() and then does the multiplications/divisions as integers. Here we cast to float and
    /// then round using RoundingMode::NearestTiesToEven which is nearly identical, but not exactly the
    /// same for all values. Values may differ by 1.
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, Mpp16s aAlpha, DevPtrMpp16s aDst,
                                           size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Premultiplies pixels of an image with constant aAlpha value. aAlpha is expected in value range 0..1
    /// </summary>
    MPPErrorCode mppciAlphaPremulC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp16s aAlpha, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Composite two images using constant alpha values.
    /// </summary>
    MPPErrorCode mppciAlphaCompC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, Mpp16s aAlpha1,
                                         Mpp16s aAlpha2, MPPAlphaOp aAlphaOp, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             MPPFixedFilter aFilter, MPPMaskSize aMaskSize, const Mpp16s aConstant[3],
                                             MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MPPFixedFilter aFilter, MPPMaskSize aMaskSize, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                                MPPFixedFilter aFilter, MPPMaskSize aMaskSize,
                                                const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a mpp::FixedFilter to the source image.
    /// </summary>
    MPPErrorCode mppciFixedFilter_16s32s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                              MPPFixedFilter aFilter, MPPMaskSize aMaskSize, MPPBorderType aBorder,
                                              MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                 MppiSize aDstSize, ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize,
                                                 Mpp32s aFilterCenter, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                                 MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined seperable filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciSeparableFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                              const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined column wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciColumnFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                            MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                    MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                    MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                    Mpp32s aFilterCenter, const Mpp16s aConstant[3],
                                                    MPPBorderType aBorder, MppiRect aSrcROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a column wise box-filter to the image, i.e. the pixels are summed up along columns with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciColumnWindowSum_16s32f_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                  MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                  Mpp32s aFilterCenter, MPPBorderType aBorder, MppiRect aSrcROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                           const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined row wise filter to the image. Note that the filter parameters must sum up to 1.
    /// </summary>
    MPPErrorCode mppciRowFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                         MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp32f aDst, size_t aDstStep,
                                                 MppiSize aDstSize, Mpp32f aScalingValue, Mpp32s aFilterSize,
                                                 Mpp32s aFilterCenter, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                                 MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies a row wise box-filter to the image, i.e. the pixels are summed up along rows with the specified
    /// length. The result is then scaled by aScalingValue.
    /// </summary>
    MPPErrorCode mppciRowWindowSum_16s32f_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                               Mpp32f aScalingValue, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                              MppiFilterArea aFilterArea, const Mpp16s aConstant[3],
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an averaging box-filter to the image.
    /// </summary>
    MPPErrorCode mppciBoxFilter_16s32f_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp32f aDst, size_t aDstStep, MppiSize aDstSize,
                                            MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the maximum pixel value.
    /// </summary>
    MPPErrorCode mppciMaxFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The filter finds in the neighborhood of each pixel defined in aFilterArea the minimum pixel value.
    /// </summary>
    MPPErrorCode mppciMinFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Median filter (only filter sizes 3x3, 5x5 and 7x7 are implemented).
    /// </summary>
    MPPErrorCode mppciMedianFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              MppiFilterArea aFilterArea, const Mpp32f aNoise[3],
                                              const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies Wiener filter to the image.
    /// </summary>
    MPPErrorCode mppciWienerFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            MppiFilterArea aFilterArea, const Mpp32f aNoise[3], MPPBorderType aBorder,
                                            MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                            MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                            MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                            const Mpp32f aDelta[3], const Mpp16s aValGT[3],
                                                            const Mpp16s aValLE[3], const Mpp16s aConstant[3],
                                                            MPPBorderType aBorder, MppiRect aSrcROI,
                                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average pixel values of the pixels under a mask.
    /// Once the neighborhood average around a source pixel is determined the source pixel is compared to the average
    /// aDelta and if the source pixel is greater than that average the corresponding destination pixel is set to
    /// aValGT, otherwise aValLE.
    /// </summary>
    MPPErrorCode mppciThresholdAdaptiveBoxFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                          MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                          MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                          const Mpp32f aDelta[3], const Mpp16s aValGT[3],
                                                          const Mpp16s aValLE[3], MPPBorderType aBorder,
                                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea,
                                        const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp32f aFilter,
                                      MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                         ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies an user defined filter, the filter parameters should sum up to 1.<para/>
    /// Note that the filter is applied in "cross-correlation orientation" and not in "convolution orientation", i.e.
    /// the filter has the same orientation as the image (same behavior as in Matlab, mirrored filter as compared to
    /// NPP).
    /// </summary>
    MPPErrorCode mppciFilter_16s32s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp32s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32f aFilter, MppiFilterArea aFilterArea,
                                           const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    /// <param name="aNorm">Norm to use when computing the pixel weight for multi-channel images.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                      MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                      MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                      ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                      MPPNorm aNorm, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                                      MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Applies the bilateral Gauss filter to the image using pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().
    /// </summary>
    /// <param name="aDst">Destination image.</param>
    /// <param name="aFilterArea">Size of the filter.</param>
    /// <param name="aPreCompGeomDistCoeff">pre-computed geometrical distance coefficients obtained
    /// from PrecomputeBilateralGaussFilter().</param>
    /// <param name="aValSquareSigma">The square of the sigma for the relative intensity distance
    /// between a source image pixel in the filter kernel and the source image pixel at the center
    /// of the filter kernel.</param>
    /// <param name="aNorm">Norm to use when computing the pixel weight for multi-channel images.</param>
    MPPErrorCode mppciBilateralGaussFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                    MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                    MppiSize aDstSize, MppiFilterArea aFilterArea,
                                                    ConstDevPtrMpp32f aPreCompGeomDistCoeff, Mpp32f aValSquareSigma,
                                                    MPPNorm aNorm, MPPBorderType aBorder, MppiRect aSrcROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_AC4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Sobel filters. Output images are only computed if the provided
    /// pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::SobelVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorSobel_16s32f_AC4R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_AC4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Scharr filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: In contrast to Sobel and Prewitt variants, the Scharr-definition for the X (vertical) gradient filter
    /// kernel is identical compared to the definition in FixedFilter::ScharrVert in order to obtain identical results
    /// as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorScharr_16s32f_AC4R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_AC4RCb(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the gradients for each pixel using fixed Prewitt filters. Output images are only computed if the
    /// provided pointer is not nullptr. If an output is set to nullptr, the result is skipped.<para/>
    /// Note: The definition for the X (vertical) gradient filter kernel is mirrored compared to the definition in
    /// FixedFilter::PrewittVert in order to obtain identical results as in NPP!
    /// </summary>
    /// <param name="aDstX">the X (vertical) gradient</param>
    /// <param name="aDstY">the Y (horizontal) gradient</param>
    /// <param name="aDstMag">the gradient magnitude</param>
    /// <param name="aDstAngle">the orientation computed using atan2</param>
    /// <param name="aDstCovariance">the covariance matrix stored in a Vector4 structure for
    /// convenience (.x is the x^2 gradient, .y is the y^2 gradient, .z and .w are x*y gradient).</param>
    /// <param name="aNorm">The norm used to compute aDstMag</param>
    /// <param name="aMaskSize">Mask size for the fixed filter</param>
    MPPErrorCode mppciGradientVectorPrewitt_16s32f_AC4R(
        ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize, DevPtrMpp32f aDstX, size_t aDstXStep,
        DevPtrMpp32f aDstY, size_t aDstYStep, DevPtrMpp32f aDstMag, size_t aDstMagStep, DevPtrMpp32f aDstAngle,
        size_t aDstAngleStep, DevPtrMpp32f aDstCovariance, size_t aDstCovarianceStep, MppiSize aDstSize, MPPNorm aNorm,
        MPPMaskSize aMaskSize, MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                               Mpp32f aWeight, Mpp32f aThreshold, const Mpp16s aConstant[3],
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Smoothes the orginal images using the user defined filter aFilter (coefficients should sum up to 1) and then
    /// subtracts the result from the original to obtain a high-pass filtered image. After thresholding and weighting,
    /// the result is added to the original image using the following pseudo-formula:<para/>
    /// HighPass = Image - Filter(Image)<para/>
    /// Result = Image + nWeight * HighPass * (| HighPass | &gt;= nThreshold) <para/>
    /// where nWeight is the amount, nThreshold is the threshold, and &gt;= indicates a Boolean operation, 1 if true, or
    /// 0 otherwise.
    /// </summary>
    MPPErrorCode mppciUnsharpFilter_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32f aFilter, Mpp32s aFilterSize, Mpp32s aFilterCenter,
                                             Mpp32f aWeight, Mpp32f aThreshold, MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                            const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from source image to destination image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffine_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                          MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                                const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpAffine, the transformation aAffine defines the mapping from destination image to source image.<para/>
    /// Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to
    /// use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpAffineBack_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              const Mpp64f aAffine[2][3], MPPInterpolationMode aInterpolation,
                                              MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                 MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                 MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                 MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                                 MPPBorderType aBorder, MppiRect aSrcROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from source image to destination
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspective_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                               DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                               const Mpp64f aPerspective[3][3], MPPInterpolationMode aInterpolation,
                                               MPPBorderType aBorder, MppiRect aSrcROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                     MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                     MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                     MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                                     MPPBorderType aBorder, MppiRect aSrcROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// WarpPerspective, the transformation aPerspective defines the mapping from destination image to source
    /// image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi differs:
    /// For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and remain as
    /// is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching outside the
    /// roi.<para/>
    /// For all other BorderType, the pixels outside the source image roi are filled (and interpolated) according to the
    /// chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>
    /// For BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciWarpPerspectiveBack_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                   MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                   MppiSize aDstSize, const Mpp64f aPerspective[3][3],
                                                   MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                                   MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                        const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                        const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Rotate, the transformation defines the mapping from source image to destination image with a counter-clock
    /// rotation around pixel(0,0) and a shift after rotation.<para/> Depending on BorderType, the behavior for pixels
    /// that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP: pixels
    /// outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRotate_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, Mpp64f aAngleInDeg,
                                      const Mpp64f aShift[2], MPPInterpolationMode aInterpolation,
                                      MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize<para/>
    /// Simplified API to rescale from source image ROI to destination image ROI.<para/>
    /// NOTE: the result is NOT the same as in NPP using the same function. The shift applied in NPP for the same
    /// function don't make much sense to me, in MPP Resize matches the input extent [-0.5 .. srcWidth-0.5[ to the
    /// output [-0.5 .. dstWidth-0.5[. Whereas NPP applies different strategies for up-and downscaling. In order to get
    /// the same results as in NPP, use an user defined scaling factor of <para/> Vec2d scaleFactor =
    /// Vec2d(dstImg.SizeRoi()) / Vec2d(srcImg.SizeRoi());<para/> and a shift given by ResizeGetNPPShift().
    /// </summary>
    MPPErrorCode mppciResize_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                     MPPInterpolationMode aInterpolation, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                                DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                                const Mpp64f aScale[2], const Mpp64f aShift[2],
                                                MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                                MPPBorderType aBorder, MppiRect aSrcROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Resize.<para/>As in ResizeSqrPixel in NPP. When mapping integer pixel coordinates from integer to floating
    /// point, in MPP the definition is as following: The integer pixel coordinate corresponds to the center of the
    /// pixel surface that thus has an extent for a pixel i from [i-0.5 .. i+0.5[ (excluding the right border). The
    /// entire valid image area then ranges from [-0.5 to width-0.5[ <para/>
    /// When rescaling, an additional shift is applied, so that the area from source image [-0.5 .. srcWidth-0.5[
    /// exactly matches
    /// [-0.5 .. dstWidth-0.5[.<para/> This shift is given by (as in NPP):<para/> InvScaleFactor = 1 / aScale;<para/>
    /// AdjustedShift  = aShift * InvScaleFactor + ((1 - InvScaleFactor) * 0.5);<para/>
    /// The output pixel with integer coordinate (X,Y) is then mapped to the source pixel:<para/>
    /// SrcX = InvScaleFactor.x * X - AdjustedShift.x;<para/>
    /// SrcY = InvScaleFactor.y * Y - AdjustedShift.y;<para/>
    /// Depending on BorderType, the behavior for
    /// pixels that fall outside the source image roi differs: For BorderType::None, the behavior is similiar to NPP:
    /// pixels outside the roi are not written to and remain as is, though at the image border, BorderType::Replicate is
    /// applied for interpolation kernels reaching outside the roi.<para/> For all other BorderType, the pixels outside
    /// the source image roi are filled (and interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For
    /// BorderType::Constant, the constant value to use must be provided.
    /// </summary>
    MPPErrorCode mppciResizeSqrPixel_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              const Mpp64f aScale[2], const Mpp64f aShift[2],
                                              MPPInterpolationMode aInterpolation, MPPBorderType aBorder,
                                              MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis
    /// </summary>
    MPPErrorCode mppciMirror_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                     MPPMirrorAxis aAxis, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Mirror<para/>
    /// Mirror an image along the provided axis (inplace operation)
    /// </summary>
    MPPErrorCode mppciMirror_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, MPPMirrorAxis aAxis, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                         MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                         MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemapC2_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                       ConstDevPtrMpp32f aCoordinateMap, size_t aCoordinateMapStep,
                                       MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/> For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                       ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                       ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                       MPPInterpolationMode aInterpolation, const Mpp16s aConstant[3],
                                       MPPBorderType aBorder, MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Remap, for each destination image pixel, the coordinate map contains its mapped floating point coordinate in the
    /// source image.<para/> Depending on BorderType, the behavior for pixels that fall outside the source image roi
    /// differs: For BorderType::None, the behavior is similiar to NPP: pixels outside the roi are not written to and
    /// remain as is, though at the image border, BorderType::Replicate is applied for interpolation kernels reaching
    /// outside the roi.<para/> For all other BorderType, the pixels outside the source image roi are filled (and
    /// interpolated) according to the chosen BorderType.<para/>
    /// For BorderType::Mirror, BorderType::MirrorReplicate and BorderType::Wrap, only pixels once the width or
    /// height of the source image roi on each side is allowed for pixels outside the original roi. For transforms that
    /// fall outside this expanded area, the pixel value is not defined. <para/>For BorderType::Constant, the constant
    /// value to use must be provided.
    /// </summary>
    MPPErrorCode mppciRemap_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                     ConstDevPtrMpp32f aCoordinateMapX, size_t aCoordinateMapXStep,
                                     ConstDevPtrMpp32f aCoordinateMapY, size_t aCoordinateMapYStep,
                                     MPPInterpolationMode aInterpolation, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the entire mask area defined by aFilterArea (maximum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilation_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                         DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                         MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                         MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the entire mask area defined by aFilterArea (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosion_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                       MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                             const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs erosion on the mask area defined by aFilterArea and where aMask is != 0 (minimum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionMask_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                             DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                             ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea,
                                             const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-erosion on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciErosionGray_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                           DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                           ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                           MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                              const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs dilation on the mask area defined by aFilterArea and where aMask is != 0 (maximum pixel in the
    /// neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationMask_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                            MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                              ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea,
                                              const Mpp16s aConstant[3], MPPBorderType aBorder, MppiRect aSrcROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Performs gray-scale-dilation on the mask area defined by aFilterArea. The value of aMask is added to the pixel
    /// value and clamped to pixel type value range before comparison (minimum pixel in the neighborhood).
    /// </summary>
    MPPErrorCode mppciDilationGray_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                            DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize,
                                            ConstDevPtrMpp32s aMask, MppiFilterArea aFilterArea, MPPBorderType aBorder,
                                            MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                      MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                      MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies erosion then dilation.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciOpen_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                    DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                    DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                    MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                       DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                       DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                       MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                       MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// First applies dilation then erosion.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciClose_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                     DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                     DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                     MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                        MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                        MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the original image minus the result from morphological opening.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciTopHat_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                      DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                      DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                      MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                          DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                          MppiFilterArea aFilterArea, const Mpp16s aConstant[3], MPPBorderType aBorder,
                                          MppiRect aSrcROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The result is the result from morphological closing minus the original image.<para/>
    /// aTemp is a temporary image of the same size and type as the source / destination image for intermediate results.
    /// </summary>
    MPPErrorCode mppciBlackHat_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step, MppiSize aSrcFullSize,
                                        DevPtrMpp16s aTempBasePtr, size_t aTempStep, MppiSize aTempFullSize,
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                        MppiFilterArea aFilterArea, MPPBorderType aBorder, MppiRect aSrcROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_AC4RCb(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                    MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                    MppiSize aDstSize, ConstDevPtrMpp8u aMask,
                                                    MppiFilterArea aFilterArea, const Mpp16s aConstant[3],
                                                    MPPBorderType aBorder, MppiRect aSrcROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Dilation minus erosion.
    /// </summary>
    MPPErrorCode mppciMorphologyGradient_16s_AC4R(ConstDevPtrMpp16s aSrc1BasePtr, size_t aSrc1Step,
                                                  MppiSize aSrcFullSize, DevPtrMpp16s aDst, size_t aDstStep,
                                                  MppiSize aDstSize, ConstDevPtrMpp8u aMask, MppiFilterArea aFilterArea,
                                                  MPPBorderType aBorder, MppiRect aSrcROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageErrorBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average error is defined as: AverageError = Sum(|Src1(i,j) - Src2(i,j)|)/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageError_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                               size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                               ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for AverageRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciAverageRelativeErrorBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/> For multi-channel images, the result is computed for each channel seperatly in
    /// aDst, or for all channels in aDstScalar. <para/> If the image is in complex format, the absolute value is used
    /// for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the average relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the average relative error is defined as: AverageRelativeError = Sum(|Src1(i,j) - Src2(i,j)| / max(|Src1(i,j)|,
    /// |Src2(i,j)|))/(W * H) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciAverageRelativeError_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                       ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                       DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask,
                                                       size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProduct.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for DotProductMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciDotProductBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j)) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the dot product of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the dot product is defined as: DotProduct = Sum(Src1(i,j) * Src2(i,j)) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciDotProduct_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSE.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSEMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSEBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                     size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer,
                                     size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Mean Square Error of two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the MSE is defined as: MSE = Sum((Src1(i,j) - Src2(i,j))^2) / (W*H) <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSE_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                      ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumErrorBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum error is defined as: MaximumError = max(|Src1(i,j) - Src2(i,j)|) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.<para/>
    /// Note: Same as NormDiffInf
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumError_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                               size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                               ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeError.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaximumRelativeErrorMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaximumRelativeErrorBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/> For multi-channel images, the result is computed for each channel
    /// seperatly in aDst, or for all channels in aDstScalar. <para/> If the image is in complex format, the absolute
    /// value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                      DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the maximum relative error between two images where only pixels with mask != 0 are used.<para/>
    /// Given two images Src1 and Src2 both with width W and height H,
    /// the maximum relative error is defined as: MaximumRelativeError = max((|Src1(i,j) - Src2(i,j)|) /
    /// max(|Src1(i,j)|, |Src2(i,j)|)) <para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar. <para/> If the image is in complex format, the absolute value is used for computation.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaximumRelativeError_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                       ConstDevPtrMpp16s aSrc2, size_t aSrc2Step, DevPtrMpp64f aDst,
                                                       DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask,
                                                       size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffInfBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm of difference of pixels between two images.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The infinity norm of differences is defined as: NormDiffInf = max((|Src1(i,j) - Src2(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffInf_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                              ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL1BufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm of difference of pixels between two images.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The L1 norm of differences is defined as: NormDiffL1 = sum((|Src1(i,j) - Src2(i,j)|)<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL1_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormDiffL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormDiffL2BufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm of difference of pixels between two images.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The L2 norm of differences is defined as: NormDiffL2 = sqrt(sum(((Src1(i,j) - Src2(i,j))^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormDiffL2_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelInfBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative infinity norm of difference of pixels between two images.<para/>
    /// The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) / NormInf(Src2)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative infinity norm of difference of pixels between two images where only pixels with mask != 0
    /// are used.<para/> The relative infinity norm of differences is defined as: NormRelInf = NormDiffInf(Src1, Src2) /
    /// NormInf(Src2)<para/> For multi-channel images, the result is computed for each channel seperatly in aDst, or for
    /// all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelInf_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                             size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                             ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL1BufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L1 norm of difference of pixels between two images.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L1 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The relative L1 norm of differences is defined as: NormRelL1 = NormDiffL1(Src1, Src2) / NormL1(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL1_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormRelL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormRelL2BufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L2 norm of difference of pixels between two images.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                           DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the relative L2 norm of difference of pixels between two images where only pixels with mask != 0 are
    /// used.<para/>
    /// The relative L2 norm of differences is defined as: NormRelL2 = NormDiffL2(Src1, Src2) / NormL2(Src2)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second image to compare aSrc1 image to</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormRelL2_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar,
                                            ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                            size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for PSNR.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciPSNRBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the PSNR of two images. <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aValueRange">The maximum possible pixel value, eg. 255 for 8 bit unsigned int images,
    /// 4095 for 12-bit unsigned images, etc.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciPSNR_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp64f aDstScalar, Mpp64f aValueRange,
                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInf.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormInfMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormInfBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                         DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the infinity norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The infinity norm is defined as: NormInf = max(|Src1(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormInf_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                          DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                          DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL1Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL1BufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L1 norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The L1 norm is defined as: NormL1 = sum(|Src1(i,j)|)<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL1_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                         DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for NormL2Masked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciNormL2BufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                        DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the L2 norm where only pixels with mask != 0 are
    /// used.<para/>
    /// The L2 norm is defined as: NormL2 = sqrt(sum(Src1(i,j)^2))<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciNormL2_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                         DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                         DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Sum.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SumMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aDst">Used as output type indicator</param>
    MPPErrorCode mppciSumBufferSize_16s64f_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                     DevPtrMpp64s aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                     DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                     MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64s aDst,
                                      DevPtrMpp64s aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the sum of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSum_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                      DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                      DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Mean.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                      DevPtrMpp64f aDstScalar, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean of pixel values where only pixels with mask != 0 are used.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMean_16s64f_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aDst,
                                       DevPtrMpp64f aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                       DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStd.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MeanStdMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMeanStdBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aMean">Per-channel mean value, can be nullptr if aStd is also nullptr</param>
    /// <param name="aStd">Per-channel standard deviation value, can be nullptr if aMean is also nullptr</param>
    /// <param name="aMeanScalar">Mean value for all channels, can be nullptr if aStdScalar is also nullptr</param>
    /// <param name="aStdScalar">Standard deviation for all channels, can be nullptr if aMeanScalar is also
    /// nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                      DevPtrMpp64f aMeanScalar, DevPtrMpp64f aStdScalar, DevPtrMpp8u aBuffer,
                                      size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the mean and standard deviation of pixel values where only pixels with mask != 0 are used.<para/>For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aMean">Per-channel mean value, can be nullptr if aStd is also nullptr</param>
    /// <param name="aStd">Per-channel standard deviation value, can be nullptr if aMean is also nullptr</param>
    /// <param name="aMeanScalar">Mean value for all channels, can be nullptr if aStdScalar is also nullptr</param>
    /// <param name="aStdScalar">Standard deviation for all channels, can be nullptr if aMeanScalar is also
    /// nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMeanStd_16s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp64f aMean, DevPtrMpp64f aStd,
                                       DevPtrMpp64f aMeanScalar, DevPtrMpp64f aStdScalar, ConstDevPtrMpp8u aMask,
                                       size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for CountInRangeMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciCountInRangeBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range.<para/>For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aLowerLimit[3],
                                              const Mpp16s aUpperLimit[3], DevPtrMpp64u aDst, DevPtrMpp64u aDstScalar,
                                              DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Counts the pixels in a given value range where only pixels with mask != 0 are used.<para/>For multi-channel
    /// images, the result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aLowerLimit">Lower bound of the specified range (inclusive).</param>
    /// <param name="aUpperLimit">Upper bound of the specified range (inclusive).</param>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCountInRange_16s64u_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aLowerLimit[3],
                                               const Mpp16s aUpperLimit[3], DevPtrMpp64u aDst, DevPtrMpp64u aDstScalar,
                                               ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer,
                                               size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the image quality index of two images. This implementation is identical to the one in NPP computing a
    /// global index without a sliding window.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndex_16s64f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, DevPtrMpp64f aDst, DevPtrMpp8u aBuffer,
                                              size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for QualityIndexWindow.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciQualityIndexWindowBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the QualityIndex of two images. This function is implemented using a sliding window approach as is done
    /// in the original paper / code with a window size of 11x11 pixels.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciQualityIndexWindow_16s32f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                                    size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer,
                                                    size_t aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for SSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciSSIMBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically this is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciSSIM_16s32f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                      size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                      CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MSSSIM.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMSSSIMBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the Multi-Scale-SSIM of two images.
    /// Note: This implementation differs slightly from NPP as the exact parameters used are unknown. Here we follow the
    /// reference matlab implementation provided here: https://ece.uwaterloo.ca/~z70wang/research/ssim/. The only
    /// difference is in the filtering steps for image borders where MPP applies replication.
    /// </summary>
    /// <param name="aSrc2">Second source image</param>
    /// <param name="aDst">Per channel result</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aDynamicRange">The value range of the image. Typically aSrc1 is 2^BitsPerPixel - 1.</param>
    /// <param name="aK1">Stabilisation constant 1, Default=0.01</param>
    /// <param name="aK2">Stabilisation constant 2, Default=0.03</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMSSSIM_16s32f_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, DevPtrMpp32f aDst, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                        Mpp32f aDynamicRange, Mpp32f aK1, Mpp32f aK2, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Min.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value.
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                  DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value where only pixels with mask != 0 are used.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMin_16s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                   DevPtrMpp16s aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                   DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for Max.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value.
    /// <para/> For multi-channel images, the
    /// result is computed for each channel seperatly in aDst, or for all channels in aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, DevPtrMpp16s aDstScalar,
                                  DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value where only pixels with mask != 0 are used.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDst, or for all channels in
    /// aDstScalar.
    /// </summary>
    /// <param name="aDst">Per-channel result, can be nullptr</param>
    /// <param name="aDstScalar">Result for all channels, can be nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMax_16s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                   DevPtrMpp16s aDstScalar, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                   DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMax.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value.<para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax, or for all
    /// channels in aDstMinScalar/aDstMaxScalar.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstMax is also nullptr</param>
    /// <param name="aDstMax">Per-channel maximum value, can be nullptr if aDstMin is also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr if aDstMaxScalar also nullptr</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels, can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                     DevPtrMpp16s aDstMax, DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                     DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value where only pixels with mask != 0 are used.<para/>
    /// For multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax, or for all
    /// channels in aDstMinScalar/aDstMaxScalar.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstMax is also nullptr</param>
    /// <param name="aDstMax">Per-channel maximum value, can be nullptr if aDstMin is also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr if aDstMaxScalar also nullptr</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels, can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMax_16s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                      DevPtrMpp16s aDstMax, DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                      ConstDevPtrMpp8u aMask, size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinIndexBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is computed for each
    /// channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the minimum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                       DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMinScalar,
                                       DevPtrMpp32s aDstScalarIdx, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels
    /// in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel minimum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Minimum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the minimum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinIndex_16s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                        DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMinScalar,
                                        DevPtrMpp32s aDstScalarIdx, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                 CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMaxIndexBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                  CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index. For multiple occurences of the same value the index with the lowest
    /// flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is computed for each
    /// channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel maximum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Maximum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the maximum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                       DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMaxScalar,
                                       DevPtrMpp32s aDstScalarIdx, DevPtrMpp8u aBuffer, size_t aBufferSize,
                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Maximum pixel value and its pixel index where only pixels with mask != 0 are used. For multiple occurences of
    /// the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel
    /// images, the result is computed for each channel seperatly in aDstMin/aDstIndexX/aDstIndexY, or for all channels
    /// in aDstMinScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Per-channel maximum value, can be nullptr if aDstIndexX and aDstIndexY are also
    /// nullptr</param>
    /// <param name="aDstIndexX">Per-channel X pixel index, can be nullptr if aDstMin and aDstIndexY are
    /// also nullptr</param>
    /// <param name="aDstIndexY">Per-channel Y pixel index, can be nullptr if aDstMin and
    /// aDstIndexX are also nullptr</param>
    /// <param name="aDstMinScalar">Maximum value for all channels, can be nullptr
    /// if aDstScalarIdx also nullptr</param>
    /// <param name="aDstScalarIdx">Pixel index of the maximum value, the .z
    /// component gives the image channel of the value. Can be nullptr if aDstMinScalar also nullptr</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMaxIndex_16s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMax,
                                        DevPtrMpp32s aDstIndexX, DevPtrMpp32s aDstIndexY, DevPtrMpp16s aDstMaxScalar,
                                        DevPtrMpp32s aDstScalarIdx, ConstDevPtrMpp8u aMask, size_t aMaskStep,
                                        DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndex.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_AC4(size_t *aBufferSize, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for MinMaxIndexMasked.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    MPPErrorCode mppciMinMaxIndexBufferSize_16s_AC4M(size_t *aBufferSize, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices. For multiple occurences of the same value the index
    /// with the lowest flattened index (y * width + x) is returned.<para/> For multi-channel images, the result is
    /// computed for each channel seperatly in aDstMin/aDstMax/aDstIdx, or for all channels in
    /// aDstMinScalar/aDstMaxScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Minimum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMax and aDstIdx are also nullptr.</param>
    /// <param name="aDstMax">Maximum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstIdx are also nullptr.</param>
    /// <param name="aDstIdx">Pixel index for min and max value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstMax are also nullptr.</param>
    /// <param name="aDstMinScalar">Minimum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMaxScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstScalarIdx">Pixel index for min and max value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstMaxScalar are also nullptr.</param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                          DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx,
                                          DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                          DevPtrMppiIndexMinMaxChannel aDstScalarIdx, DevPtrMpp8u aBuffer,
                                          size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Minimum and maximum pixel value and their pixel indices where only pixels with mask != 0 are used. For multiple
    /// occurences of the same value the index with the lowest flattened index (y * width + x) is returned.<para/> For
    /// multi-channel images, the result is computed for each channel seperatly in aDstMin/aDstMax/aDstIdx, or for all
    /// channels in aDstMinScalar/aDstMaxScalar/aDstScalarIdx.
    /// </summary>
    /// <param name="aDstMin">Minimum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMax and aDstIdx are also nullptr.</param>
    /// <param name="aDstMax">Maximum value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstIdx are also nullptr.</param>
    /// <param name="aDstIdx">Pixel index for min and max value per channel (array with size of active channels).
    /// Can be nullptr if aDstMin and aDstMax are also nullptr.</param>
    /// <param name="aDstMinScalar">Minimum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMaxScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstMaxScalar">Maximum value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstScalarIdx are also nullptr.</param>
    /// <param name="aDstScalarIdx">Pixel index for min and max value for all channels (array with size of 1).
    /// Can be nullptr if aDstMinScalar and aDstMaxScalar are also nullptr.</param>
    /// <param name="aMask"></param>
    /// <param name="aBuffer">Temporary device memory buffer for computation.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciMinMaxIndex_16s_AC4M(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstMin,
                                           DevPtrMpp16s aDstMax, DevPtrMppiIndexMinMax aDstIdx,
                                           DevPtrMpp16s aDstMinScalar, DevPtrMpp16s aDstMaxScalar,
                                           DevPtrMppiIndexMinMaxChannel aDstScalarIdx, ConstDevPtrMpp8u aMask,
                                           size_t aMaskStep, DevPtrMpp8u aBuffer, size_t aBufferSize, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = min(aSrc1, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = min(aSrcDst, aSrc2) (minimum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMinEvery_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst = max(aSrc1, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                       size_t aSrc2Step, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                       CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aSrcDst = max(aSrcDst, aSrc2) (maximum per pixel, per channel)
    /// </summary>
    MPPErrorCode mppciMaxEvery_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramEven.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramEvenBufferSize_16s_AC4(size_t *aBufferSize, const Mpp32s aNumLevels[3],
                                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// The aLowerLevel (inclusive) and aUpperLevel (exclusive) define the boundaries of the range,
    /// which are evenly segmented into aHist.Size() bins.
    /// </summary>
    /// <param name="aHist">host array of device memory pointers to the computed histograms
    /// (one for each active channel). The size of aHist[channel] gives the number of bins used.</param>
    /// <param name="aLowerLevel">lower level (inclusive, per channel)</param>
    /// <param name="aUpperLevel">upper level (exclusive, per channel)</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramEven_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist[3],
                                            const Mpp32s aLowerLevel[3], const Mpp32s aUpperLevel[3],
                                            Mpp32s aNumLevels[3], DevPtrMpp8u aBuffer, size_t aBufferSize,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Returns the required temporary buffer size for HistogramRange.<para/>
    /// Note: the buffer size differs for varying ROI sizes.
    /// </summary>
    /// <param name="aNumLevels">aNumLevels - 1 = number of histogram bins, per channel</param>
    MPPErrorCode mppciHistogramRangeBufferSize_16s_AC4(size_t *aBufferSize, const Mpp32s aNumLevels[3],
                                                       MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Computes the histogram of an image within specified ranges.
    /// </summary>
    /// <param name="aHist">host array of device memory pointers to the computed histograms
    /// (one for each active channel). The size of aHist[channel] gives the number of bins used.</param>
    /// <param name="aLevels">host array of device memory pointers to the array
    /// with the range defintions, one array per channel. The levels array must be one element
    /// larger than the histogram array, as number of levels = number of bins + 1.</param>
    /// <param name="aBuffer"></param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciHistogramRange_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp32s aHist[3],
                                             ConstDevPtrMpp32s aLevels[3], Mpp32s aNumLevels[3], DevPtrMpp8u aBuffer,
                                             size_t aBufferSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciCircularRadialProfile_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                    DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                    DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                    const Mpp32f aCenter[2], MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Radial profile. Circular around provided center point, the center does not have to be on the image.
    /// </summary>
    /// <param name="aProfileCount">The number of pixels that have the distance of the array index to the center
    /// point.</param>
    /// <param name="aProfileSum">Per-channel sum, one element per radius. Must be of the same size as
    /// aProfileCount.</param>
    /// <param name="aProfileSumSqr">Per-channel squared sum, if provided the array must have the same size as
    /// aProfileSum, can be nullptr.</param>
    /// <param name="aCenter">The center of the circular average.</param>
    /// <param name="aRadiusRatio">Ratio of orientation axis to orthogonal axis. (i.e. 1.5 means stretched 1.5x)</param>
    /// <param name="aAngleInDeg">Orientation of the ellipse's orthogonal axis, clockwise in degrees with 0.0 being
    /// vertical.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciEllipticalRadialProfile_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                      DevPtrMpp32s aProfileCount, DevPtrMpp32f aProfileSum,
                                                      DevPtrMpp32f aProfileSumSqr, size_t aProfileSize,
                                                      const Mpp32f aCenter[2], Mpp32f aRadiusRatio, Mpp32f aAngleInDeg,
                                                      MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_AC4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                          size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                          MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_AC4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                           MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_AC4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                              MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aSrc2 fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompare_16s8u_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep,
                                        MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompareC_16s8u_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                         MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to 255 if aSrc1 and aConst fulfill aCompare, 0 otherwise.<para/>
    /// The comparison is performed for each channel individually and the flag CompareOp::PerChannel must be set for
    /// aCompare.
    /// </summary>
    MPPErrorCode mppciCompareDevC_16s8u_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                            MPPCompareOp aCompare, DevPtrMpp8u aDst, size_t aDstStep, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThreshold_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                        MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                            MPPCompareOp aCompare, DevPtrMpp16s aDst, size_t aDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                          DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aThreshold,
                                              DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThreshold_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                         MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdDevC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                             MPPCompareOp aCompare, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLT_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTDevC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                               MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGT_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                           MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aThreshold, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTDevC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aThreshold,
                                               MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                           const Mpp16s aValue[3], MPPCompareOp aCompare, DevPtrMpp16s aDst,
                                           size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                             const Mpp16s aValue[3], DevPtrMpp16s aDst, size_t aDstStep,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThreshold[3],
                                             const Mpp16s aValue[3], DevPtrMpp16s aDst, size_t aDstStep,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation aCompare the predicate (sourcePixel aCompare nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdVal_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                            const Mpp16s aValue[3], MPPCompareOp aCompare, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation less than the predicate (sourcePixel &lt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTVal_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                              const Mpp16s aValue[3], MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation greater than the predicate (sourcePixel &gt; nThreshold) is true, the pixel is set
    /// to aValue, otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdGTVal_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThreshold[3],
                                              const Mpp16s aValue[3], MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel.
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aThresholdLT[3],
                                            const Mpp16s aValueLT[3], const Mpp16s aThresholdGT[3],
                                            const Mpp16s aValueGT[3], DevPtrMpp16s aDst, size_t aDstStep,
                                            MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// If for a comparison operation sourcePixel is less than aThresholdLT is true, the pixel is set
    /// to aValueLT, else if sourcePixel is greater than aThresholdGT the pixel is set to aValueGT,
    /// otherwise it is set to sourcePixel. (Inplace operation)
    /// </summary>
    MPPErrorCode mppciThresholdLTGT_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aThresholdLT[3],
                                             const Mpp16s aValueLT[3], const Mpp16s aThresholdGT[3],
                                             const Mpp16s aValueGT[3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aSrc2 fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                        size_t aSrc2Step, MPPCompareOp aCompare, const Mpp16s aValue[3],
                                        DevPtrMpp16s aDst, size_t aDstStep, MppiSize aSizeROI,
                                        CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, const Mpp16s aConst[3],
                                         MPPCompareOp aCompare, const Mpp16s aValue[3], DevPtrMpp16s aDst,
                                         size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// aDst pixel is set to aValue if aSrc1 and aConst fulfill aCompare, aSrc1 otherwise.<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aConst,
                                            MPPCompareOp aCompare, const Mpp16s aValue[3], DevPtrMpp16s aDst,
                                            size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aSrc2 fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIf_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                         size_t aSrc2Step, MPPCompareOp aCompare, const Mpp16s aValue[3],
                                         MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp16s aConst[3],
                                          MPPCompareOp aCompare, const Mpp16s aValue[3], MppiSize aSizeROI,
                                          CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// A pixel is set to aValue if aSrcDst and aConst fulfill aCompare, aSrcDst otherwise (inplace operation).<para/>
    /// The flag CompareOp::AnyChannel controls how the comparison is performed for multi channel images:<para/>
    /// CompareOp::Eq is true only if all channels in a pixel are equal whereas <para/>
    /// CompareOp::Eq | CompareOp::AnyChannel is true if any of the channels in a pixel is equal.<para/>
    /// Without the CompareOp::PerChannel flag, a pixel is compared for all channels and replaced by all channels. With
    /// the CompareOp::PerChannel flag, each channel is compared and replaced seperately.
    /// </summary>
    MPPErrorCode mppciReplaceIfDevC_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aConst,
                                             MPPCompareOp aCompare, const Mpp16s aValue[3], MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, const Mpp32f aTwist[3][3], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_AC4P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                              size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                              DevPtrMpp16s aDst3, size_t aDst3Step, const Mpp32f aTwist[3][3],
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_P3AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                              DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][3],
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix (inplace)
    /// </summary>
    MPPErrorCode mppciColorTwist3x3_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp32f aTwist[3][3],
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422 (YCbCr/YCrCb/CbYCr).
    /// </summary>
    /// <param name="aDstLumaChroma">Destination image with Luma/Chroma interleaved</param>
    /// <param name="aTwist"></param>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciColorTwist3x3To422_16s_AC4C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                   DevPtrMpp16s aDstLumaChroma, size_t aDstLumaChromaStep,
                                                   const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                   bool aSwapLumaChroma, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To422_16s_AC4P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                   const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To422_16s_AC4P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                   size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                   size_t aDstChroma2Step, const Mpp32f aTwist[3][3],
                                                   MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To420_16s_AC4P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                   const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To420_16s_AC4P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                   size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                   size_t aDstChroma2Step, const Mpp32f aTwist[3][3],
                                                   MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To411_16s_AC4P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                   const Mpp32f aTwist[3][3], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x3To411_16s_AC4P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                   size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                   size_t aDstChroma2Step, const Mpp32f aTwist[3][3],
                                                   MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From422_16s_P2AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma, size_t aSrcChromaStep, DevPtrMpp16s aDst,
                                                     size_t aDstStep, const Mpp32f aTwist[3][3],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From422_16s_P3AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                     DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step,
                                                     DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][3],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From420_16s_P2AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma, size_t aSrcChromaStep, DevPtrMpp16s aDst,
                                                     size_t aDstStep, const Mpp32f aTwist[3][3],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From420_16s_P3AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                     DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step,
                                                     DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][3],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From411_16s_P2AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma, size_t aSrcChromaStep, DevPtrMpp16s aDst,
                                                     size_t aDstStep, const Mpp32f aTwist[3][3],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x3 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x3From411_16s_P3AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                     DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step,
                                                     DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][3],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, const Mpp32f aTwist[3][4], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_AC4P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst1,
                                              size_t aDst1Step, DevPtrMpp16s aDst2, size_t aDst2Step,
                                              DevPtrMpp16s aDst3, size_t aDst3Step, const Mpp32f aTwist[3][4],
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_P3AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                              size_t aSrc2Step, ConstDevPtrMpp16s aSrc3, size_t aSrc3Step,
                                              DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][4],
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix (inplace)
    /// </summary>
    MPPErrorCode mppciColorTwist3x4_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, const Mpp32f aTwist[3][4],
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422 (YCbCr/YCrCb/CbYCr).
    /// </summary>
    /// <param name="aDstLumaChroma">Destination image with Luma/Chroma interleaved</param>
    /// <param name="aTwist"></param>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    /// <param name="aStreamCtx"></param>
    MPPErrorCode mppciColorTwist3x4To422_16s_AC4C2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step,
                                                   DevPtrMpp16s aDstLumaChroma, size_t aDstLumaChromaStep,
                                                   const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                   bool aSwapLumaChroma, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To422_16s_AC4P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                   const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To422_16s_AC4P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                   size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                   size_t aDstChroma2Step, const Mpp32f aTwist[3][4],
                                                   MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To420_16s_AC4P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                   const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To420_16s_AC4P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                   size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                   size_t aDstChroma2Step, const Mpp32f aTwist[3][4],
                                                   MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To411_16s_AC4P2(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma, size_t aDstChromaStep,
                                                   const Mpp32f aTwist[3][4], MPPChromaSubsamplePos aChromaSubsamplePos,
                                                   MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma downsampling to 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    MPPErrorCode mppciColorTwist3x4To411_16s_AC4P3(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDstLuma,
                                                   size_t aDstLumaStep, DevPtrMpp16s aDstChroma1,
                                                   size_t aDstChroma1Step, DevPtrMpp16s aDstChroma2,
                                                   size_t aDstChroma2Step, const Mpp32f aTwist[3][4],
                                                   MPPChromaSubsamplePos aChromaSubsamplePos, MppiSize aSizeROI,
                                                   CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From422_16s_P2AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma, size_t aSrcChromaStep, DevPtrMpp16s aDst,
                                                     size_t aDstStep, const Mpp32f aTwist[3][4],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 422.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From422_16s_P3AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                     DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step,
                                                     DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][4],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From420_16s_P2AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma, size_t aSrcChromaStep, DevPtrMpp16s aDst,
                                                     size_t aDstStep, const Mpp32f aTwist[3][4],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 420.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From420_16s_P3AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                     DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step,
                                                     DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][4],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From411_16s_P2AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma, size_t aSrcChromaStep, DevPtrMpp16s aDst,
                                                     size_t aDstStep, const Mpp32f aTwist[3][4],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// ColorTwist with a 3x4 matrix and chroma upsampling from 411.
    /// </summary>
    /// <param name="aChromaSubsamplePos">Position of the chroma sample point relative to luma</param>
    /// <param name="aSwapLumaChroma">Cb/Cr can be swapped in the TwistMatrix, but Luma and Chroma can only swapped with
    /// this parameter. Set to true for CbYCr.</param>
    MPPErrorCode mppciColorTwist3x4From411_16s_P3AC4(DevPtrMpp16s aSrcLuma, size_t aSrcLumaStep,
                                                     DevPtrMpp16s aSrcChroma1, size_t aSrcChroma1Step,
                                                     DevPtrMpp16s aSrcChroma2, size_t aSrcChroma2Step,
                                                     DevPtrMpp16s aDst, size_t aDstStep, const Mpp32f aTwist[3][4],
                                                     MPPChromaSubsamplePos aChromaSubsamplePos,
                                                     MPPInterpolationMode aInterpolationMode, MppiSize aSizeROI,
                                                     CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                             size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                             CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrBT709_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                              MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                                size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                                CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using BT.709 curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrBT709_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                                 MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion linear to gamma corrected using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaCorrsRGB_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                             MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                               size_t aDstStep, Mpp32f aNormFactor, MppiSize aSizeROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Conversion gamma corrected to linear using sRGB curve. The values are normalized to [0..1] before the
    /// operation using aNormFactor. For 8u images this is usually 255.0f.
    /// </summary>
    MPPErrorCode mppciGammaInvCorrsRGB_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, Mpp32f aNormFactor,
                                                MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a color gradient image to grayscale.
    /// </summary>
    MPPErrorCode mppciGradientColorToGray_16s_AC4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                                    size_t aDstStep, MPPNorm aNorm, MppiSize aSizeROI,
                                                    CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Converts a multi-channel color image to a one channel gray scale image where each channel is weighted by the
    /// factor provided in aWeights.<para/> Common values to convert RGB to gray are nGray = 0.299 * R + 0.587 * G +
    /// 0.114 * B
    /// </summary>
    MPPErrorCode mppciColorToGray_16s_AC4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                            size_t aDstStep, const Mpp32f aWeights[3], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// RGB Color to Grayscale Bayer Color Filter Array conversion.<para/>
    /// Depending on the chosen BayerGridPosition and pixel position, only either red, green or blue channel is stored
    /// in the destionation image.<para/> Image ROI must have even width and height.
    /// </summary>
    MPPErrorCode mppciRGBToCFA_16s_AC4C1(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                         MPPBayerGridPosition aBayerGrid, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion.<para/> aPalette is a pointer to number of color channels
    /// arrays of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst, size_t aDstStep,
                                         ConstDevPtrMpp16s aPalette[3], Mpp32s aBitSize, MppiSize aSizeROI,
                                         CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Palette look-up-table color conversion - inplace.<para/> aPalette is a pointer to number of color channels
    /// arrays of at least 2^aBitSize elements.<para/> aBitSize must be in range [1..(8*sizeof(pixel base type)].
    /// </summary>
    MPPErrorCode mppciLUTPalette_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aPalette[3],
                                          Mpp32s aBitSize, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 3 elements per pixel (red, green, blue).
    /// </summary>
    MPPErrorCode mppciLUTTrilinear_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                           size_t aDstStep, ConstDevPtrMpp16s aLut3D, const Mpp16s aMinLevel[3],
                                           const Mpp16s aMaxLevel[3], const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                           CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 4 elements per pixel (red, green, blue), 4th channel is unused and is only
    /// for padding.
    /// </summary>
    MPPErrorCode mppciLUTTrilinearAC4_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, DevPtrMpp16s aDst,
                                              size_t aDstStep, ConstDevPtrMpp16s aLut3D, const Mpp16s aMinLevel[3],
                                              const Mpp16s aMaxLevel[3], const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                              CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation - inline.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 3 elements per pixel (red, green, blue).
    /// </summary>
    MPPErrorCode mppciLUTTrilinear_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aLut3D,
                                            const Mpp16s aMinLevel[3], const Mpp16s aMaxLevel[3],
                                            const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// Look-up-table color conversion using a 3D LUT and tri-linear interpolation - inline.<para/>
    /// For C4 pixel types, the alpha channel is copied from source to destination image, for C4A the alpha channel in
    /// destination image remains untouched.<para/>
    /// aLut3D is an array of size aLutSize.x * aLutSize.y * aLutSize.z, where the blue channel axis is the fastest
    /// moving one. The LUT is provided with 4 elements per pixel (red, green, blue), 4th channel is unused and is only
    /// for padding.
    /// </summary>
    MPPErrorCode mppciLUTTrilinearAC4_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aLut3D,
                                               const Mpp16s aMinLevel[3], const Mpp16s aMaxLevel[3],
                                               const Mpp32s aLutSize[3], MppiSize aSizeROI,
                                               CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrc1 source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the destination image aDst.
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_AC4(ConstDevPtrMpp16s aSrc1, size_t aSrc1Step, ConstDevPtrMpp16s aSrc2,
                                           size_t aSrc2Step, const Mpp16s aColorKey[3], DevPtrMpp16s aDst,
                                           size_t aDstStep, MppiSize aSizeROI, CPtrMppCudaStreamCtx aStreamCtx);

    /// <summary>
    /// All pixels of the aSrcDst source image equal to the specified key color aColorKey are replaced with the
    /// corresponding pixel of the background image aSrc2 and stored in the same source image (inplace operation).
    /// </summary>
    MPPErrorCode mppciCompColorKey_16s_AC4I(DevPtrMpp16s aSrcDst, size_t aSrcDstStep, ConstDevPtrMpp16s aSrc2,
                                            size_t aSrc2Step, const Mpp16s aColorKey[3], MppiSize aSizeROI,
                                            CPtrMppCudaStreamCtx aStreamCtx);

#ifdef __cplusplus
}
#endif
#endif // MPPI_CUDA_CAPI_16S_H
